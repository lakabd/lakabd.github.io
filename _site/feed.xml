<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Abderrahim LAKBIR&#39;s Blog</title>
    <description>Welcome to my blog.
</description>
    <link>https://lakabd.github.io/</link>
    <atom:link href="https://lakabd.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 10 Nov 2020 16:41:59 +0100</pubDate>
    <lastBuildDate>Tue, 10 Nov 2020 16:41:59 +0100</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Projet YOCTO : Build d‚Äôune image Linux-RT pour Beaglebone Black</title>
        <description>&lt;p&gt;La carte Beaglbone black (&lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;) est une plateforme embarqu√©e open source utilis√©e dans plusieurs domaines √©ducationnels ainsi qu‚Äôindustriels. Equip√©e d‚Äôun &lt;code class=&quot;highlighter-rouge&quot;&gt;SOC&lt;/code&gt; am335x de Texas Instrument, cette plateforme est capable de tourner diff√©rents syst√®mes d‚Äôexploitation comme Linux, Android, WinCE‚Ä¶ 
&lt;!--end_excerpt--&gt;&lt;/p&gt;

&lt;p&gt;Dans certaines applications, notamment dans le domaine industriel, il est parfois exig√© d‚Äôavoir une performance temps r√©el du system, ce qui n√©cessite l‚Äôutilisation d‚Äôune solution temps r√©el soit software ou hardware. Dans cet article, nous allons s‚Äôint√©resser √† une solution software open source d√©di√©e au system Linux connue sous le nom : le projet &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‚ÄúControlling a laser with Linux is crazy, but everyone in this room is crazy in his own way. So, if you want to use Linux to control an industrial welding laser, I have no problem with your using PREEMPT_RT.‚Äù ‚Äì Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Le projet &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt; (fond√© et maintenu par Thomas Gleixner, Ingo Molnar et de nombreux autres collaborateurs) offre une solution temps r√©el ¬´ souple ¬ª qui se pr√©sente sous forme d‚Äôun patch qu‚Äôon peut appliquer sur un noyau Linux standard pour am√©liorer ses performances pour le temps r√©el. L‚Äôapplication du patch &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt; se fait sur le code source d‚Äôun noyau Linux avant sa compilation. Toutefois, comme le patch n‚Äôest disponible que pour des versions majeures et mineures bien pr√©cises du noyau Linux standard, l‚Äôapplication du patch peut s‚Äôav√©rer d‚Äôune grande complexit√© √† cause des probl√®mes de compatibilit√©.&lt;/p&gt;

&lt;p&gt;L‚Äôobjectif de cet article est d‚Äôinvestiguer une technique automatis√©e de construction d‚Äôimage Linux embarqu√© avec le fameux projet Yocto, ceci, en construisant une image Linux patch√©e avec &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt; pour la cible &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;. Dans La premi√®re partie, une introduction au syst√®me de construction du projet Yocto et de ses importants outils est pr√©sent√©e. Dans la deuxi√®me partie, nous allons voir la configuration r√©alis√©e pour la construction d‚Äôune image Linux-RT bas√©e sur un noyau fourni par Texas Instrument, puis, nous concluons par faire une comparaison de la performance offerte par cette solution temps r√©el, par rapport √† une impl√©mentation Linux normal.&lt;/p&gt;

&lt;h2 id=&quot;projet-yocto&quot;&gt;Projet Yocto&lt;/h2&gt;

&lt;p&gt;Le projet Yocto est un projet collaboratif, open source, cr√©√© par la fondation Linux en 2011 avec l‚Äôobjectif de fournir et de cr√©er des outils et processus interop√©rables pour la construction des images Linux personnalis√©es d√©di√©es aux syst√®mes embarqu√©s et IoT, peut-import leurs architectures hardware. Le projet Yocto offre un environnement de d√©veloppement flexible, qui permet aux d√©veloppeurs de syst√®mes embarqu√©s de collaborer √† travers une technologie partag√©e de piles logicielles, de configurations et des meilleures pratiques utilis√©es pour cr√©er des images Linux personnalis√©es.&lt;/p&gt;

&lt;p&gt;Ce projet est bas√© sur une plateforme appel√©e &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenEmbedded&lt;/code&gt; cr√©√©e en 2003, qui est une plateforme de compilation crois√©e automatis√©e, d√©di√©e √† la construction des images Linux embarqu√©e. Le system de construction de cette plateforme utilise un outil qui s‚Äôappelle &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt;, similaire √† l‚Äôoutil &lt;code class=&quot;highlighter-rouge&quot;&gt;GNU Make&lt;/code&gt;, et qui permet de sp√©cifier les scriptes de construction - appel√©e ¬´ recettes ¬ª dans le langage &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; - d‚Äôun package donn√©. Les recettes &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; (extension &lt;code class=&quot;highlighter-rouge&quot;&gt;.bb&lt;/code&gt;) incluent la liste des d√©pendances de chaque package, la location du source code, et toutes autres informations n√©cessaires qui permettent aux outils &lt;code class=&quot;highlighter-rouge&quot;&gt;d‚ÄôOpenEmbedded&lt;/code&gt; de cr√©er une image Linux bootable.&lt;/p&gt;

&lt;p&gt;Dans la repos officielle ( üïä j‚Äôai l‚Äôhabitude d‚Äôutiliser le mot ‚Äúla repos‚Äù √† la place de ‚Äú le d√©p√¥t‚Äù conform√©ment au mot anglais dominant : Repository ) du projet Yocto : &lt;a href=&quot;https://git.yoctoproject.org/&quot;&gt;git.yoctoproject.org&lt;/a&gt;, nous trouvons une distribution de r√©f√©rence appel√©e &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;, qui contient le syst√®me de construction &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenEmbedded&lt;/code&gt; plus un ensemble de m√©tadonn√©es permettant aux d√©veloppeurs d‚Äôamorcer la construction de leurs distributions personnalis√©es. Cette r√©f√©rence est fournie comme une sp√©cification de base et elle permet - out of the box - de construire une image bootable pour un syst√®me embarqu√© typique.&lt;/p&gt;

&lt;p&gt;La figure ci-dessous illustre la relation de &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt; avec le reste du projet :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170005870.png&quot; alt=&quot;image-20201108170016427&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pour en savoir plus sur &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;, voir le lien : &lt;a href=&quot;https://www.yoctoproject.org/docs/2.5/overview-manual/overview-manual.html#reference-embedded-distribution&quot;&gt;Reference Embedded Distribution (Poky)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;mod√®le-en-couche&quot;&gt;Mod√®le en couche&lt;/h3&gt;

&lt;p&gt;L‚Äôun des points forts du projet Yocto et que chaque aspect de construction est contr√¥l√© via des m√©tadonn√©es. En effet, Il est possible d‚Äôajouter/modifier des couches de m√©tadonn√©es permettant l‚Äôajout de nouvelles piles logicielles, du support pour le nouveau hardware (Board Support Packages) ou m√™me cr√©er des nouveaux types d‚Äôimages (image minimale, basique‚Ä¶).&lt;/p&gt;

&lt;p&gt;Le mod√®le en couche du projet Yocto sert √† isoler les diff√©rentes personnalisations ajout√©es, dans le but d‚Äôam√©liorer la flexibilit√© et la r√©utilisabilit√© de ses diff√©rents processus de construction : plus la structure est modulaire plus et facile de coop√©rer avec les changements futurs.&lt;/p&gt;

&lt;p&gt;Chaque couche Yocto respecte une hi√©rarchie bien pr√©cise, permettant de garder la compatibilit√© et la portabilit√© avec les autres couches du projet. Par commodit√© d‚Äôutilisation, le nom des couches Yocto commence toujours par le pr√©fix &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-&lt;/code&gt; . Ci-dessous, la composition typique d‚Äôune couche Yocto :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170028468.png&quot; alt=&quot;image-20201108170028468&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Une couche Yocto est compos√©e d‚Äôun dossier obligatoire conf qui contient :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Un fichier de configuration &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.conf&lt;/code&gt; indiquant les diff√©rentes recettes offertes par cette couche.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Un dossier machine qui contient le fichier de configuration &lt;code class=&quot;highlighter-rouge&quot;&gt;machine.conf&lt;/code&gt; li√© √† la plateforme cible.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Plus des dossiers de recettes qui ajoutent le support de nouvelles fonctionnalit√©s, ou √©tendent celles existantes d√©j√† dans autres couches  (fichiers &lt;code class=&quot;highlighter-rouge&quot;&gt;.bbappend&lt;/code&gt;). Dans la couche de la figure ci-dessus, nous trouvons, en plus du conf, le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;recipes-kernel&lt;/code&gt; qui contient une recette &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; (.bb) pour la construction d‚Äôun noyau Linux.&lt;/p&gt;

&lt;h4 id=&quot;couche-bsp&quot;&gt;Couche BSP&lt;/h4&gt;

&lt;p&gt;En effet, les couches Yocto qui ajoutent du support √† des nouvelles machines sont appel√©es des couches &lt;code class=&quot;highlighter-rouge&quot;&gt;BSP&lt;/code&gt; (Board Support Packages). Il s‚Äôagit d‚Äôune collection d‚Äôinstructions et d‚Äôinformations (des m√©tadonn√©es) qui d√©finit comment prendre en charge un syst√®me ou p√©riph√©rique mat√©riel. Elles incluent des informations sur les fonctionnalit√©s mat√©rielles pr√©sentes sur le p√©riph√©rique, les informations de configuration du noyau ainsi que tout pilote mat√©riel suppl√©mentaire requis. Elles ajoutent √©galement tous les composants logiciels suppl√©mentaires en addition au stack Linux, pour les fonctionnalit√©s du p√©riph√©rique essentielles et facultatives.&lt;/p&gt;

&lt;h3 id=&quot;bitbake&quot;&gt;Bitbake&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BitBake&lt;/code&gt; se trouve au c≈ìur du syst√®me de build &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenEmbedded&lt;/code&gt;. C‚Äôest un syst√®me g√©n√©rique d‚Äôex√©cution de t√¢ches (√©crit en &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;), qui permet aux t√¢ches &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; d‚Äô√™tre ex√©cut√©es efficacement et en parall√®le tout en travaillant dans des contraintes de d√©pendance inter-t√¢ches complexes.&lt;/p&gt;

&lt;p&gt;Conceptuellement, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitBake&lt;/code&gt; est similaire √† &lt;code class=&quot;highlighter-rouge&quot;&gt;GNU Make&lt;/code&gt; √† certains √©gards :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BitBake&lt;/code&gt; ex√©cute les t√¢ches en fonction des m√©tadonn√©es fournies de chaque package. Les m√©tadonn√©es sont stock√©es dans les fichiers recettes (&lt;code class=&quot;highlighter-rouge&quot;&gt;.bb&lt;/code&gt;), fichiers de configuration (&lt;code class=&quot;highlighter-rouge&quot;&gt;.conf&lt;/code&gt;) et de classe (&lt;code class=&quot;highlighter-rouge&quot;&gt;.bbclass&lt;/code&gt;) qui fournissent √† &lt;code class=&quot;highlighter-rouge&quot;&gt;BitBake&lt;/code&gt; toutes les instructions sur les t√¢ches √† ex√©cuter et leurs interd√©pendances.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BitBake&lt;/code&gt; inclut toute une biblioth√®que d√©dier √† la r√©cup√©ration du code source de divers endroits (syst√®mes de contr√¥le de source, serveurs Web,‚Ä¶) et qui supporte plusieurs protocoles : git, https, ftp, file, ssh‚Ä¶&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; utilise un model client/serveur, qui permet de l‚Äôutiliser √† partir de la ligne de commande ou comme un service via XML-RPC.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;les-recettes-bitbake-&quot;&gt;Les recettes Bitbake :&lt;/h4&gt;

&lt;p&gt;Ce sont des fichiers d√©sign√©s par l‚Äôextension &lt;code class=&quot;highlighter-rouge&quot;&gt;.bb&lt;/code&gt;, et ils repr√©sentent les briques √©l√©mentaires des m√©tadonn√©es. Chaque fichier recette, fournit toutes les informations n√©cessaires √† la construction du package correspondant. Ces informations sont organis√©es dans des variables ou cod√©es dans des fonctions pr√©d√©finies par &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Une description du package : Dans la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;DESCRIPTION&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La version de la recette : Dans la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;PV&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Les d√©pendances existantes : Dans la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;DEPENDS&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La location du source code du package : Dans la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_URI&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La location des diff√©rents patches √† appliquer au code source, s‚Äôil y en existe : Dans la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC_URI&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Comment configurer et compiler le code source : Dans les fonction &lt;code class=&quot;highlighter-rouge&quot;&gt;do_configure()&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;do_compile()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;O√π installer le package : Dans la fonction &lt;code class=&quot;highlighter-rouge&quot;&gt;do_install()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En addition, les recettes &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; utilisent une convention de nommage standard qui inclut le nom du package plus sa version dans le nom de la recette. C‚Äôest une r√®gle de nommage √† respecter, comme ces valeurs sont automatiquement prises par &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; et lui permet de localiser toutes les recettes disponibles et leurs versions correspondantes. Le format attendu du nom d‚Äôune recette est le suivant : &lt;code class=&quot;highlighter-rouge&quot;&gt;packagename_version-r1.bb&lt;/code&gt; avec &lt;code class=&quot;highlighter-rouge&quot;&gt;r1&lt;/code&gt; le num√©ro du release (s‚Äôil n‚Äôest pas sp√©cifi√©, sa valeur par d√©faut est &lt;code class=&quot;highlighter-rouge&quot;&gt;r0&lt;/code&gt;). Par exemple, dans la couche Yocto de la figure pr√©c√©dente, nous avions une recette pour la construction d‚Äôun package &lt;code class=&quot;highlighter-rouge&quot;&gt;linux-yocto&lt;/code&gt; de version &lt;code class=&quot;highlighter-rouge&quot;&gt;5.4&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note : Pour choisir cette recette dans le build d‚Äôune machine, au cas o√π il y‚Äôen a plusieurs pour diff√©rentes versions, il suffit de sp√©cifier dans le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;machine.conf&lt;/code&gt; la version pr√©f√©r√©e en utilisant la notation suivante :        &lt;code class=&quot;highlighter-rouge&quot;&gt;PREFERRED_VERSION_linux-yocto = &quot;5.4&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;construction-dune-image-temps-r√©el-pour-la-beaglebone-black&quot;&gt;Construction d‚Äôune image temps r√©el pour la BeagleBone Black&lt;/h2&gt;

&lt;h3 id=&quot;pr√©paration-du-workspace&quot;&gt;Pr√©paration du Workspace&lt;/h3&gt;

&lt;p&gt;Pour utiliser le projet Yocto, il est n√©cessaire d‚Äôabord d‚Äôavoir une machine de d√©veloppement avec un minimum de 50 Go d‚Äôespace disque libre et qui ex√©cute une distribution Linux prise en charge (voir le &lt;a href=&quot;http://www.yoctoproject.org/docs/2.4.2/ref-manual/ref-manual.html#detailed-supported-distros&quot;&gt;lien&lt;/a&gt;).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Installation des packages essentiels :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ce sont les principaux outils et packages n√©cessaires √† la construction avec le projet Yocto. Ceux-ci incluent le compilateur &lt;code class=&quot;highlighter-rouge&quot;&gt;GNU GCC&lt;/code&gt;, un syst√®me de contr√¥le de versions, plus d‚Äôautres packages, selon ce qu‚Äôon veut faire (ajouter du support graphique, g√©n√©rer la doc ‚Ä¶ etc). Ci-dessous la commande pour obtenir l‚Äôessentiel sur Ubuntu :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;R√©cup√©ration des couches de m√©tadonn√©es n√©cessaires :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour notre cible &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;, nous allons se baser sur la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;, mais en plus, nous avons besoin de la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;BSP&lt;/code&gt; sp√©cifique au hardware de la carte &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;. Pour cela, nous allons utiliser la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt; de la part de Texas Instrument (qui est le vendeur du &lt;code class=&quot;highlighter-rouge&quot;&gt;SOC&lt;/code&gt; amx335 de la carte &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;) fournie dans la repos officielle du projet Yocto. Dans cette couche, en plus des recettes &lt;code class=&quot;highlighter-rouge&quot;&gt;BSP&lt;/code&gt; qui incluent les configurations hardwares, nous trouvons les recettes de construction des noyaux &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux-rt&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;non-rt&lt;/code&gt; fournies par TI, ainsi que des recettes personnalis√©es avec des fonctionnalit√©s suppl√©mentaires compatibles avec la carte &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Pour notre image nous avons besoin donc, de deux couches : &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;, plus &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt;. Comme ces deux couches sont des repos Git contenant plusieurs branches, nous allons se baser sur les commits &lt;code class=&quot;highlighter-rouge&quot;&gt;sumo19.0.0&lt;/code&gt; (de la branche sumo) pour &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;ti2018.02&lt;/code&gt; pour &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt; (ce choix est bas√© sur les travaux de &lt;a href=&quot;https://bootlin.com/doc/training/yocto/yocto-labs.pdf&quot;&gt;Bootlin&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Sous un nouveau dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;yocto_workspace&lt;/code&gt;, ex√©cuter les commandes suivantes dans le terminal pour r√©cup√©rer le code source des deux repos :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://git.yoctoproject.org/git/Poky
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://git.yoctoproject.org/git/meta-ti
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;Poky &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; BBB sumo-19.0.0
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;meta-ti &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; BBB ti2018.02
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;configuration-des-couches-yocto&quot;&gt;Configuration des couches Yocto&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Configuration de la couche Poky :&lt;/p&gt;

    &lt;p&gt;Nous commen√ßons premi√®rement par ‚Äúsourcer‚Äù le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;oe-init-build-env&lt;/code&gt; qui permet de cr√©er l‚Äôenvironnement de build :&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;Poky &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;oe-init-build-env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Apres ex√©cution, nous nous trouvons avec un nouveau dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt; sous le r√©pertoire &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;, contenant deux fichiers de configuration dans un sous-dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;conf&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;bblayers.conf&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;local.conf&lt;/code&gt;. Ces deux fichiers sont √† la base de toute la configuration du syst√®me de construction.&lt;/p&gt;

    &lt;p&gt;Le premier fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;bblayers.conf&lt;/code&gt;, comme son nom l‚Äôindique, il sert √† configurer les couches dans le syst√®me de construction. Ce fichier contient, parmi d‚Äôautres informations, le chemin vers toutes les couches qui seront utilis√©es dans la construction sous la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;BBLAYERS&lt;/code&gt;. Ci-dessous un aper√ßu sur le contenu par d√©faut de cette variable :&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170051528.png&quot; alt=&quot;image-20201108170051528&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Notre int√©r√™t est d‚Äôutiliser la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;BSP&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt;, pour cela nous devons remplacer la derni√®re couche &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-Poky-bsp&lt;/code&gt; par le chemin vers la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt; que nous avons t√©l√©charg√©e. Les deux premi√®re couches &lt;code class=&quot;highlighter-rouge&quot;&gt;meta&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-Poky&lt;/code&gt; constituent l‚Äôensemble des m√©tadonn√©es de base du syst√®me de construction et nous devons les garder.&lt;/p&gt;

    &lt;p&gt;Pour le deuxi√®me fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;local.conf&lt;/code&gt;, il sert √† d√©finir toutes les configurations &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt; de l‚Äôutilisateur local. Dans ce fichier nous d√©finissons des valeurs pour diff√©rentes variables de configuration. Toute variable d√©finie dans ce fichier remplace toute autre d√©finition de cette variable dans la repos &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt; (sauf si celle-ci est cod√©e en dur : en utilisant &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; √† la place de &lt;code class=&quot;highlighter-rouge&quot;&gt;?=&lt;/code&gt;). Ci-dessous, les modifications que nous devons apporter √† ce fichier pour notre cible &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt; :&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Configuration de la machine cible : &lt;code class=&quot;highlighter-rouge&quot;&gt;MACHINE = &quot;beaglebone&quot;&lt;/code&gt;.
&lt;em&gt;Attention&lt;/em&gt; : √† ne pas confondre avec &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglbone-yocto&lt;/code&gt;, ce sont deux machines diff√©rentes. N‚Äôoubliez pas de commenter toute autre d√©finition de cette variable.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Ajouter les packages essentiels de d√©veloppement ( &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pkgconfig&lt;/code&gt; ‚Ä¶) plus les outils de profilage (module &lt;code class=&quot;highlighter-rouge&quot;&gt;lttng&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;valgrind&lt;/code&gt;, ‚Ä¶) √† l‚Äôimage g√©n√©r√©e : 
&lt;code class=&quot;highlighter-rouge&quot;&gt;EXTRA_IMAGE_FEATURES ?= &quot;debug-tweaks tools-sdk tools-profile&quot;&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Configuration de la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt; :&lt;/p&gt;

    &lt;p&gt;Cette couche repr√©sente notre couche &lt;code class=&quot;highlighter-rouge&quot;&gt;BSP&lt;/code&gt;. Elle contient des fichiers de configuration pour plusieurs machines sous le r√©pertoire &lt;code class=&quot;highlighter-rouge&quot;&gt;conf/machine&lt;/code&gt;. Parmi ces fichiers, on trouve &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglbone.conf&lt;/code&gt; qui correspond au fichier de configuration pour notre carte &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt; (c‚Äôest le nom de ce fichier que nous avons donn√© √† la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;MACHINE&lt;/code&gt; dans le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;local.conf&lt;/code&gt; de la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;). En plus du dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;conf&lt;/code&gt;, nous trouvons des dossiers de recettes pour diff√©rents packages : &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;connectivity&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;graphics&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;multimedia&lt;/code&gt;‚Ä¶&lt;/p&gt;

    &lt;p&gt;Sous le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;recipes-kernel/linux&lt;/code&gt; nous trouvons la recette du &lt;code class=&quot;highlighter-rouge&quot;&gt;noyau-rt&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;linux-ti-staging-rt_4.14.bb&lt;/code&gt; que nous allons utiliser pour construire notre image temps r√©el.&lt;/p&gt;

    &lt;p&gt;L‚Äôunique modification de cette couche, concerne le fichier de configuration &lt;code class=&quot;highlighter-rouge&quot;&gt;conf/machine/beaglbone.conf&lt;/code&gt;. Dans ce fichier nous devons indiquer au syst√®me de construction que nous voudrons utiliser le &lt;code class=&quot;highlighter-rouge&quot;&gt;noyau-rt&lt;/code&gt; dans le &lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt; de l‚Äôimage pour cette machine, et ce, en se basant sur la recette &lt;code class=&quot;highlighter-rouge&quot;&gt;linux-ti-staging-rt_4.14.bb&lt;/code&gt;. Cette modification consiste d‚Äôajouter les deux lignes suivantes dans le fichier de configuration :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PREFERRED_PROVIDER_virtual/kernel = &quot;linux-ti-staging-rt&quot;
COMPATIBLE_MACHINE_beaglebone = &quot;beaglebone&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Il est n√©cessaire aussi d‚Äôint√©grer les modules noyau dans l‚Äôimage finale en ajoutant la ligne ci-dessous :&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MACHINE_EXTRA_RRECOMMENDS += &quot;kernel-modules&quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;cr√©ation-dune-image-rt&quot;&gt;Cr√©ation d‚Äôune image RT&lt;/h3&gt;

&lt;p&gt;Apr√®s configuration des deux couches, notre syst√®me de build est pr√™t pour g√©n√©rer une image Linux. Par d√©faut, la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt; fournit un ensemble de type d‚Äôimage pr√™te √† √™tre construite avec &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-minimal&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-sato&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-base&lt;/code&gt;‚Ä¶&lt;/p&gt;

&lt;p&gt;Pour construire une image minimale, il suffit d‚Äôex√©cuter la commande :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;Bitbake core-image-minimal 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A la fin d‚Äôex√©cution de &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt;, les art√©facts de construction sont g√©n√©r√©s dans le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;build/tmp/deploy/image/beaglbone/&lt;/code&gt; :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;am335x-boneblack.dtb&lt;/code&gt; : ce fichier correspond au Device Tree Blob, qui d√©crit les p√©riph√©riques de la carte &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt; au noyau Linux.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MLO&lt;/code&gt; : Memory Loader, qui sert √† initialiser le syst√®me et charger &lt;code class=&quot;highlighter-rouge&quot;&gt;u-boot&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;u-boot.img&lt;/code&gt; : l‚Äôimage du bootloader &lt;code class=&quot;highlighter-rouge&quot;&gt;u-boot&lt;/code&gt;. Le r√¥le final de u-boot est de charger le noyau Linux dans la DDR et de lui passer le contr√¥le.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zImage&lt;/code&gt; : c‚Äôest l‚Äôimage binaire du noyau Linux !&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-minimal.rootfs.tar.xz&lt;/code&gt; : fichier compress√© du syst√®me de fichier Linux. 
&lt;em&gt;Note&lt;/em&gt; : Le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;boot&lt;/code&gt; du rootfs contient par d√©faut la &lt;code class=&quot;highlighter-rouge&quot;&gt;zImage&lt;/code&gt; et le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;dtb&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modules-4.14.93-r0.tgz&lt;/code&gt; : compress√© des modules que nous avons construits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-minimal.rootfs.wic.xz&lt;/code&gt; : ce fichier compress√© contient tous les √©l√©ments pr√©c√©dents dans une seule image de type &lt;code class=&quot;highlighter-rouge&quot;&gt;.wic&lt;/code&gt;. Cette image inclut des commandes de partitionnement permettant d‚Äôautomatiser le portage de tous les √©l√©ments de l‚Äôimage dans le support de la plateforme cible (ex : carte microSD).
&lt;em&gt;Note&lt;/em&gt; : le nom &lt;code class=&quot;highlighter-rouge&quot;&gt;WIC&lt;/code&gt; est d√©riv√© de &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenEmbedded&lt;/code&gt; Image Creator : &lt;code class=&quot;highlighter-rouge&quot;&gt;OEIC-&amp;gt;WIC&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tous les art√©facts g√©n√©r√©s sont sp√©cifi√©s par les recettes &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; li√©es √† l‚Äôimage construite : &lt;code class=&quot;highlighter-rouge&quot;&gt;image-core-minimal.bb&lt;/code&gt;, et √† la machine &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglbone.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Pour le temps de construction √©coul√© de cette image minimale, il d√©pend essentiellement de deux param√®tres : le d√©bit internet et la puissance de calcul de la machine h√¥te. Sur ma machine locale (2 coeurs et un d√©bit moyen de 500Ko/s), le build de l‚Äôimage minimal a pris environ 6 heures. Apr√®s le premier build, Le projet Yocto garde le code source de tous les packages qui a construit sous le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;build/downloads&lt;/code&gt; pour ne pas les ret√©l√©charger dans les prochains build.&lt;/p&gt;

&lt;p&gt;Comme cette image n‚Äôest qu‚Äôune image minimale, elle ne contient que le n√©cessaire des outils et librairie pour faire marcher une version Linux minimaliste. Donc, on y trouve ni outil de communication : &lt;code class=&quot;highlighter-rouge&quot;&gt;telnet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;.., ni package manager et surtout aucun outil de tests temps r√©el comme le package &lt;code class=&quot;highlighter-rouge&quot;&gt;rt-tests&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Pour r√©soudre cela, l‚Äôune des solutions est d‚Äôessayer d‚Äôinstaller tous les packages manquants de fa√ßon manuelle. Or, √† cause des diff√©rentes d√©pendances entre les packages et les librairies‚Ä¶ cette solution risque d‚Äô√™tre tr√®s fastidieuse. La deuxi√®me solution, qui est plut√¥t √† port√©e de main, est de demander √† &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; de les installer pour nous, comme les recettes de tous les packages dont nous avons besoin existent d√©j√† dans la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;Poky&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Nous avons d√©cid√© de cr√©er une nouvelle image (recette) appel√©e &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglbone-ti-image-rt.bb&lt;/code&gt;, dans laquelle nous sp√©cifions toutes les caract√©ristiques et packages suppl√©mentaires dont nous avons besoin. Pour ne pas recr√©er une recette √† z√©ro de toute la base de l‚Äôimage, nous allons baser celle-l√† sur l‚Äôimage existante &lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-base.bb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Le contenu de cette nouvelle image est pr√©sent√© dans la figure ci-dessous :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170118287.png&quot; alt=&quot;image-20201108170118287&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Premi√®rement, nous avons commenc√© par importer l‚Äôimage &lt;code class=&quot;highlighter-rouge&quot;&gt;core-image-base.bb&lt;/code&gt;. Puis, nous avons cr√©√© un script python (optionnel), pour stopper &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt; si l‚Äôutilisateur n‚Äôa pas sp√©cifi√© son noyau pr√©f√©r√© au &lt;code class=&quot;highlighter-rouge&quot;&gt;noyau-rt&lt;/code&gt; de TI : &lt;code class=&quot;highlighter-rouge&quot;&gt;linux-ti-staging-rt&lt;/code&gt;. En addition, nous ajoutons les packages et fonctionnalit√©s suppl√©mentaires ci-dessous √† l‚Äôimage finale via les variables &lt;code class=&quot;highlighter-rouge&quot;&gt;IMAGE_INSTALL&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;IMAGE_FEATURES&lt;/code&gt; :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rt-tests&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;hwlatdetect&lt;/code&gt; : ces deux packages contiennent les outils de test temps r√©el, comme &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;hackbench&lt;/code&gt; ‚Ä¶&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dropbear&lt;/code&gt; : ce package contient le client &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;dropbear&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;package-managment&lt;/code&gt; : ce package permet d‚Äôinstaller les outils de gestion des packages apt.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-server-dropbear&lt;/code&gt; : Installer le serveur &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt; minimal &lt;code class=&quot;highlighter-rouge&quot;&gt;dropbear&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IMPORTANT : Pour respecter la structure des couches Yocto, cette nouvelle recette est plac√©e sous un nouveau dossier images/ dans le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;recipes-core/&lt;/code&gt; de la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Comme pr√©c√©demment, nous g√©n√©rons cette nouvelle image en lan√ßant la commande :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;Bitbake beaglbone-ti-image-rt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A la fin de l‚Äôex√©cution, qui prend bien beaucoup plus de temps que l‚Äôimage minimale, nous obtenons la sortie suivante :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201109003537657.png&quot; style=&quot;zoom: 90%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dans le dossier &lt;code class=&quot;highlighter-rouge&quot;&gt;build/tmp/deploy/image/beaglbone/&lt;/code&gt;, nous trouvons les art√©facts cit√©s pr√©c√©demment.&lt;/p&gt;

&lt;h4 id=&quot;portage-de-limage&quot;&gt;Portage de l‚Äôimage&lt;/h4&gt;

&lt;p&gt;Le fichier qui nous int√©resse pour le portage de l‚Äôimage sur une carte microSD correspond au fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;WIC&lt;/code&gt;. Ce fichier contient toutes les commandes n√©cessaires pour partitionner automatiquement la carte microSD et copier dans chaque partition les fichiers correspondants. (Il est possible aussi de porter manuellement tous les √©l√©ments de build sur la carte SD, √† la place d‚Äôutiliser le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;WIC&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Premi√®rement, nous commen√ßons par d√©compresser le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglebone-ti-image-rt.rootfs.wic.xz&lt;/code&gt; avec la commande unxz. Pour voir le contenu du fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;.wic&lt;/code&gt;, il existe l‚Äôoutil &lt;code class=&quot;highlighter-rouge&quot;&gt;wic&lt;/code&gt; fourni avec &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenEmbedded&lt;/code&gt;. Il suffit de sourcer le script &lt;code class=&quot;highlighter-rouge&quot;&gt;oe-init-build-env&lt;/code&gt; pour l‚Äôutiliser :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170811599.png&quot; alt=&quot;image-20201108170811599&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La commande &lt;code class=&quot;highlighter-rouge&quot;&gt;$ wic ls file.wic&lt;/code&gt; permet d‚Äôafficher les deux partitions contenues dans le fichier. Pour afficher le contenu de chaque partition, nous ajoutons le num√©ro de la partition devant le nom du fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;$ wic ls file.wic:2&lt;/code&gt;. D‚Äôapr√®s la figure ci-dessus, nous remarquons que notre fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;wic&lt;/code&gt; contient deux partitions : une de type &lt;code class=&quot;highlighter-rouge&quot;&gt;Fat16&lt;/code&gt; qui contient les fichiers du bootloader, et l‚Äôautre de type &lt;code class=&quot;highlighter-rouge&quot;&gt;ext4&lt;/code&gt; qui contient le system de fichier root.&lt;/p&gt;

&lt;p&gt;Avant de commencer le portage, nous ins√©rons la carte microSD dans la machine h√¥te et nous ex√©cutons la commande &lt;code class=&quot;highlighter-rouge&quot;&gt;lsblk&lt;/code&gt; pour savoir le nom du volume donn√© √† la carte microSD :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170859776.png&quot; alt=&quot;image-20201108170859776&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dans ce cas il s‚Äôagit du p√©riph√©rique &lt;code class=&quot;highlighter-rouge&quot;&gt;sdc&lt;/code&gt;, avec une partition mont√©e &lt;code class=&quot;highlighter-rouge&quot;&gt;sdc1&lt;/code&gt;. Nous d√©montons, premi√®rement, cette partition pour la d√©tach√©e du syst√®me de fichiers avec la commande :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;umount /dev/sdc?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Une fois la partition d√©mont√©e, nous √©crivons le fichier d‚Äôextension .wic directement sur l‚Äôensemble du p√©riph√©rique repr√©sentant la carte microSD :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;cp beaglbone-ti-image-rt.wic /dev/sdc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A la fin de cette op√©ration, la carte microSD est pr√™te et nous pouvons l‚Äô√©jecter de la machine h√¥te et l‚Äôins√©rer dans la &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;. Avant de d√©marrer la carte, il faut bien savoir les configurations de d√©marrage ‚Äì l‚Äôordre de boot - par d√©faut. Pour la &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt; il y en existe deux :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bouton S2 non appuy√© lors de la mise sous tension de la carte :
    &lt;ol&gt;
      &lt;li&gt;MMC1 (eMMC)&lt;/li&gt;
      &lt;li&gt;MMC0 (SD card)&lt;/li&gt;
      &lt;li&gt;UART0&lt;/li&gt;
      &lt;li&gt;USB0&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Bouton S2 appuy√© lors de la mise sous tension de la carte :
    &lt;ol&gt;
      &lt;li&gt;SPI0&lt;/li&gt;
      &lt;li&gt;MMC0 (SD card)&lt;/li&gt;
      &lt;li&gt;USB0&lt;/li&gt;
      &lt;li&gt;UART0&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Donc pour emp√™cher la carte de d√©marrer √† partir de l‚Äô&lt;code class=&quot;highlighter-rouge&quot;&gt;eMMC&lt;/code&gt; en premier, il faut rester appuyer sur le bouton &lt;code class=&quot;highlighter-rouge&quot;&gt;S2&lt;/code&gt; de la carte avant alimentation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170916357.png&quot; alt=&quot;image-20201108170916357&quot; /&gt;&lt;/p&gt;

&lt;p&gt;En branchant un adaptateur usb/FTDI au port &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; de la &lt;code class=&quot;highlighter-rouge&quot;&gt;BBB&lt;/code&gt;, et √† travers &lt;code class=&quot;highlighter-rouge&quot;&gt;minicom&lt;/code&gt;, nous obtenons la sortie suivante :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170927324.png&quot; alt=&quot;image-20201108170927324&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Donc, nous remarquons bien le bon d√©marrage du noyau Linux √† partir de la carte microSD.&lt;/p&gt;

&lt;p&gt;Pour savoir s‚Äôil s‚Äôagit d‚Äôune image temps r√©el (patch√©e avec &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt;), il suffit de voir la sortie de la commande &lt;code class=&quot;highlighter-rouge&quot;&gt;$ uname -a&lt;/code&gt; si elle affiche le string &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT RT&lt;/code&gt;, ou, de voir dans le fichier de configuration du noyau, si l‚Äôoption &lt;code class=&quot;highlighter-rouge&quot;&gt;CONFIG_PREEMPT_RT_FULL&lt;/code&gt; existe et activ√©e. La figure ci-dessous montre que notre image est bel et bien patch√©e avec &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt; :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170935854.png&quot; alt=&quot;image-20201108170935854&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A noter aussi, que cette image contient tous les outils que nous avons install√©s : &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt;‚Ä¶&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Comparaison de performance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pour r√©aliser le test de performance, nous avons construit une deuxi√®me image pour la BBB , mais cette fois-ci l‚Äôimage n‚Äôest pas RT c.√†.d elle n‚Äôest pas patch√©e par &lt;code class=&quot;highlighter-rouge&quot;&gt;PREEMPT_RT&lt;/code&gt;. Pour cela deux modifications ont √©t√© apport√©es √† la configuration pr√©c√©dente :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Remplacer le contenu de la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;PREFERRED_PROVIDER_virtual/kernel&lt;/code&gt; par &lt;code class=&quot;highlighter-rouge&quot;&gt;linux-ti-staging&lt;/code&gt; dans le fichier &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglebone.conf&lt;/code&gt; de la couche &lt;code class=&quot;highlighter-rouge&quot;&gt;meta-ti&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dans la recette de l‚Äôimage cr√©√©e &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglbone-ti-image-rt.bb&lt;/code&gt;, enlever le script python et renommer cette image √† &lt;code class=&quot;highlighter-rouge&quot;&gt;beaglebone-ti-image.bb&lt;/code&gt;. Il suffira apr√®s d‚Äôappeler cette image dans &lt;code class=&quot;highlighter-rouge&quot;&gt;Bitbake&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Maintenant que nous avons les deux images : &lt;code class=&quot;highlighter-rouge&quot;&gt;RT&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;non-RT&lt;/code&gt; avec les packages de test temps r√©el install√©s, nous pouvons comparer les deux syst√®mes. Nous allons baser notre test sur deux outils de benchmarking qui sont souvent utilis√©s dans ce contexte :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cyclictest&lt;/code&gt; : Ce programme permet de qualifier la latence du syst√®me en mesurant le temps √©coul√© entre l‚Äôexpiration d‚Äôun timer et le moment de l‚Äôex√©cution de la t√¢che qui l‚Äôa activ√© :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108170943874.png&quot; alt=&quot;image-20201108170943874&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hackbench&lt;/code&gt; : Ce programme effectue des mesures de commutation entre threads et processus qui communiquent par des pipes ou des sockets. Ce programme √©tant tr√®s intensif, nous allons l‚Äôutiliser comme √©l√©ment perturbateur pour les mesures effectu√©es avec &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les param√®tres utilis√©s pour chaque outil sont d√©crits ci-dessous :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;cyclictest &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; 0 &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 99 &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; 5m &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; 0 : ex√©cuter une seule tache sur le CPU0
    &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 99 : utiliser la priorit√© temps r√©el FIFO 99
    &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; : Invoquer mlockall&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; pour verrouiller la m√©moire virtuelle du processus en m√©moire physique &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pour √©viter les probl√®mes de page fault&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; : utiliser la fonction clock_nanosleep&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; √† la place de nanosleep&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; 5m : ex√©cuter le &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;pendant 5 minutes. Ce qui correspond √† 300000 d√©clenchement pour la valeur de sleep&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; par d√©faut qui est de 1 ms.
    &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; : &lt;span class=&quot;nt&quot;&gt;--quiet&lt;/span&gt; : afficher le r√©sultat jusqu‚Äô√† la fin de test.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hackbench &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 1024 &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; 100 &lt;span class=&quot;nt&quot;&gt;--threads&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 40 &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; 10
    &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 1024 : configurer la taille des messages √©chang√©s √† 1024 octet.
    &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; 100 : configurer le nombre de messages √©chang√© √† 100.
    &lt;span class=&quot;nt&quot;&gt;--threads&lt;/span&gt; : utiliser des threads √† la place des process.
    &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 40 : chaque √©metteur/r√©cepteur peut ouvrir 40 ‚Äòfile descriptor‚Äô.
    &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; 10 : d√©marrer 10 groupes d‚Äô√©metteur/r√©cepteur.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Les tests sont effectu√©s sur les deux images &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux-RT&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;non-RT&lt;/code&gt;. Nous allons r√©aliser deux sc√©narios de tests diff√©rents pour chaque image :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Un premier test sans charge : nous lan√ßons l‚Äôoutil &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt; tout seul.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Un deuxi√®me test avec charge intensive : nous lan√ßons &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt; dans un terminal, et en m√™me temps, nous lan√ßons &lt;code class=&quot;highlighter-rouge&quot;&gt;hackbench&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Comme nous ex√©cutons l‚Äôoutil &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt; pour une dur√©e de 5 minutes, lors des tests avec charge il faut emp√™cher &lt;code class=&quot;highlighter-rouge&quot;&gt;hackbench&lt;/code&gt; de terminer avant cette durer. Pour cela, nous avons int√©gr√© la commande &lt;code class=&quot;highlighter-rouge&quot;&gt;hackbench&lt;/code&gt; dans une boucle &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; √† l‚Äôaide du script &lt;code class=&quot;highlighter-rouge&quot;&gt;Bash&lt;/code&gt; ci-dessous :&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; :
&lt;span class=&quot;k&quot;&gt;do
     &lt;/span&gt;hackbench &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 1024 &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; 100 &lt;span class=&quot;nt&quot;&gt;--threads&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 40 &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; 10
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Apr√®s connexion √† la carte, n√©cessairement en &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt; pour √™tre capable d‚Äôouvrir deux terminaux, nous ex√©cutons les sc√©narios de tests l‚Äôun apr√®s l‚Äôautre sur les deux images Linux.&lt;/p&gt;

&lt;p&gt;Le tableau ci-dessous, r√©sume les r√©sultats obtenus de latence (mesur√©s par &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt;) pour chaque cas :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post3/image-20201108171000501.png&quot; alt=&quot;image-20201108171000501&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pour les deux sc√©narii, nous remarquons une diff√©rence sur tout l‚Äôintervalle de latence, avec un √©cart plut√¥t important pour la latence maximale entre les deux images : rapport de 10 pour le premier sc√©nario et de 4.5 pour le deuxi√®me, ce qui est bien attendu, comme les taches temps r√©el de &lt;code class=&quot;highlighter-rouge&quot;&gt;cyclictest&lt;/code&gt; prennent plus du temps &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt; sur l‚Äôimage RT (ayant un noyau pr√©emptif) que sur l‚Äôimage normale.&lt;/p&gt;

&lt;h3 id=&quot;r√©f√©rences&quot;&gt;R√©f√©rences&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html&quot;&gt;https://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yoctoproject.org/docs/2.5/dev-manual/dev-manual.html&quot;&gt;https://www.yoctoproject.org/docs/2.5/dev-manual/dev-manual.html#understanding-and-creating-layers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://bootlin.com/doc/training/yocto/yocto-labs.pdf&quot;&gt;https://bootlin.com/doc/training/yocto/yocto-labs.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://imxdev.gitlab.io/tutorial/How_to_inspect_OpenEmbedded_kickstart_wic_files/&quot;&gt;https://imxdev.gitlab.io/tutorial/How_to_inspect_OpenEmbedded_kickstart_wic_files/&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Oct 2020 14:14:45 +0100</pubDate>
        <link>https://lakabd.github.io/linux-driver/2020/10/30/post-3.html</link>
        <guid isPermaLink="true">https://lakabd.github.io/linux-driver/2020/10/30/post-3.html</guid>
        
        
        <category>linux-driver</category>
        
      </item>
    
      <item>
        <title>Linux kernel module : Building a soft UART for the Raspberry Pi - part2</title>
        <description>&lt;p&gt;In the first part of this writeup we introduced our project of building a software &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; Linux driver and we showed the implementation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol, the low-level part of the driver. In this part, we will continue on implementing the driver‚Äôs top layer, and after it‚Äôs complete, we will begin the testing part by using our &lt;code class=&quot;highlighter-rouge&quot;&gt;softUART&lt;/code&gt; as a Serial Line Internet Protocol (&lt;code class=&quot;highlighter-rouge&quot;&gt;SLIP&lt;/code&gt;) port.
&lt;!--end_excerpt--&gt;&lt;/p&gt;

&lt;h4 id=&quot;top-half&quot;&gt;Top Half&lt;/h4&gt;

&lt;p&gt;In this layer we will focus on implementing our serial driver. As mentioned in the previous part, we will build the driver upon the serial core interface.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post2/clip_image002.png&quot; alt=&quot;img&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you recall, from the diagram above, we have three main structures to define for the driver:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The structure representing the actual driver: &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_driver&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Registered using the function &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_register_driver(&amp;amp;uart_driver)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The structure representing the port included in the driver: &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_port&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;One instance for each port in the driver (at least one port must be defined. It‚Äôs possible to have many ports in a driver: &lt;code class=&quot;highlighter-rouge&quot;&gt;nr&lt;/code&gt; ports exactly)&lt;/li&gt;
      &lt;li&gt;Each port needs to added to the driver using the function &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_add_one_port(&amp;amp;uart_driver, &amp;amp;uart_port)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The structure containing the pointers to the port operations: &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_ops&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uart_state&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tty_driver&lt;/code&gt; structures are automatically initialized when the driver is registered in the kernel, and they must not be defined.&lt;/p&gt;

&lt;p&gt;In a new file &lt;code class=&quot;highlighter-rouge&quot;&gt;module.c&lt;/code&gt; we start the definition of the top half of our driver:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uart_driver&lt;/code&gt; structure:&lt;/p&gt;

    &lt;p&gt;We start by defining our &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_driver&lt;/code&gt; structure in which we give the driver a name, assign a major and a minor number to it, along with the number of ports the driver contains: only one 	port in our case.&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_driver&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_driver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THIS_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;driver_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ttySOFT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ttySOFT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*the name that will appear under /dev */&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;major&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;240&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*number of ports in this driver*/&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uart_port&lt;/code&gt; structure:&lt;/p&gt;

    &lt;p&gt;In this structure we initialize the &lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt; memory size (set to 1024 bytes), we set the pointer to our &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_ops&lt;/code&gt; structure and we specify the driver type (serial driver):&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fifosize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIFO_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*tx &amp;amp; rx buffer size*/&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_ops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TTY_DRIVER_TYPE_SERIAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*driver of type serial*/&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uart_ops&lt;/code&gt; structure:&lt;/p&gt;

    &lt;p&gt;This structure defines the operations of the port (start Tx, stop ‚Ä¶). It includes the support for a set of functions that allows the control of the hardware serial port functionalities. In our case, as we are not interested in emulating all the hardware port characteristics, we only need to implement the minimal set of functions for a normal working of the port. Below is the set of functions defined in the &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_ops&lt;/code&gt; structure:&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_ops&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx_empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_tx_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//return TIOCSER_TEMT if tx_buffer is empty, otherwise return 0
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_mctrl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_get_mctrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//get modem ctrl : return CAR|CTS|DSR
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_start_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//called by write() : start transmitting chars
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//called by open(): initialize any low level driver state
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shutdown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_shutdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//called by close() : Disable the port, and free any resources
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_termios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_set_termios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//change the port parameters : only the baudrate change is permitted in our implementation
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioctl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;softUart_ioctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Perform any port specific IOCTLs : We implement TCSETS command only.
&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Define port operations:&lt;/p&gt;

    &lt;p&gt;After the definition of the three structures, lets now start the definition of the operations initialized in the &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_ops&lt;/code&gt; structure:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_tx_empty()&lt;/code&gt; function verifies if the transmission buffer of the driver is empty. This function is called by the top layer (after each transmission) when it doesn‚Äôt receive a wakeup call from the low-level layer. If this function returns 0 (buffer not empty), a delay of 30 seconds is triggered automatically by the top layer. Therefore, to avoid this delay, we will block our function so it doesn‚Äôt return until the buffer is empty:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_tx_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........tx_empty ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isBufferEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait until buffer is empty
&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIOCSER_TEMT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_get_mctrl()&lt;/code&gt; function is called when the port is initialized. This function returns the state of the different physical signals of the serial port. In our case, we don‚Äôt implement any control signal, however, in this function, we need to return that these three signals are permanently enabled: the &lt;code class=&quot;highlighter-rouge&quot;&gt;CAR&lt;/code&gt; signal (DCD: Carrier Detect), &lt;code class=&quot;highlighter-rouge&quot;&gt;CTS&lt;/code&gt; (Clear To Send) and the &lt;code class=&quot;highlighter-rouge&quot;&gt;DSR&lt;/code&gt; (Data Set Ready)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_get_mctrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........get_mctrl ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIOCM_CAR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIOCM_CTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TIOCM_DSR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_start_tx()&lt;/code&gt; function is called when the &lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt; operation is called on the port. As its name implies, its role is to begin data transmission. The data to-send is stored in a circular buffer called &lt;code class=&quot;highlighter-rouge&quot;&gt;xmit&lt;/code&gt; and accessible via the &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_port&lt;/code&gt; pointer: &lt;code class=&quot;highlighter-rouge&quot;&gt;port-&amp;gt;state-&amp;gt;xmit&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;In this function, we start firstly by copying the to-send data from the top layer circular buffer &lt;code class=&quot;highlighter-rouge&quot;&gt;xmit&lt;/code&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Tx_buffer&lt;/code&gt; of our low-level driver (we used for that the &lt;code class=&quot;highlighter-rouge&quot;&gt;push_string()&lt;/code&gt; function defined previously in &lt;code class=&quot;highlighter-rouge&quot;&gt;circular_buffer.h&lt;/code&gt;).&lt;/p&gt;

    &lt;p&gt;After copying, we update the &lt;code class=&quot;highlighter-rouge&quot;&gt;xmit&lt;/code&gt; buffer pointers: tail and head, and we call our low-level function &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_handle_tx()&lt;/code&gt; to send the data via the &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; port:&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_start_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........start_tx ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;cm&quot;&gt;/*copy data from xmit to tx_buffer*/&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;push_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xmit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xmit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_circ_chars_pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xmit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
 &lt;span class=&quot;cm&quot;&gt;/*update xmit tail*/&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xmit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xmit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;cm&quot;&gt;/*start tx*/&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;uart_handle_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_startup()&lt;/code&gt; function is called when the &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt; operation is called on the driver. Its role is to initialize the low-level hardware. In this function we simply call the &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_init()&lt;/code&gt; function:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........startup! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;uart_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_TX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_RX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_shutdown()&lt;/code&gt; function is called when the &lt;code class=&quot;highlighter-rouge&quot;&gt;close()&lt;/code&gt; operation is called on the driver. Its role is to close the port and free all used resources:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_shutdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........shutdown! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;uart_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_set_termios()&lt;/code&gt; function is used by the user to set/get the configuration of the serial port: parity, data word size‚Ä¶ In our case, as it‚Äôs a limited implementation, we will only allow baudrate changes (also, as it will be discussed later, our implementation imposes a max and min for the baudrate). This function is called when the &lt;code class=&quot;highlighter-rouge&quot;&gt;set_termios()&lt;/code&gt; function from the library &lt;code class=&quot;highlighter-rouge&quot;&gt;termios.h&lt;/code&gt; is called:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_set_termios&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktermios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ktermios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........set_termios ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;baud&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tty_termios_baud_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*convert the desired baudrate from ktermios arg*/&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baud&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MIN_BAUDRATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baud&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_BAUDRATE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;uart_set_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baud&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;default Baudrate of 9600 is used ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CS8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CS8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Only 8bit data size is available ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARENB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARODD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;No parity bit is available ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;softUart_ioctl()&lt;/code&gt; function is pretty the same as the previous one, we define it only for compatibility reasons. This function is called when the &lt;code class=&quot;highlighter-rouge&quot;&gt;ioctl()&lt;/code&gt; operation is called on the driver, and it‚Äôs used to set/get the configuration of the serial port. We will add the support for only one &lt;code class=&quot;highlighter-rouge&quot;&gt;ioctl&lt;/code&gt; command, which is &lt;code class=&quot;highlighter-rouge&quot;&gt;TCSETS&lt;/code&gt;, that is used to set the serial port settings. If this command is called, we change only the baudrate and leave everything as it is:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;softUart_ioctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...........ioctl cmd : %x ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TCSETS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;termios&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B19200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B19200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;uart_set_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;19200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B9600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B9600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;uart_set_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B4800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B4800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;uart_set_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_cflag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B1200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B1200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;uart_set_baudrate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;default Baudrate of 9600 is used ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOIOCTLCMD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*mandatory return if cmd not supported*/&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;note:&lt;/em&gt; To ease the driver debugging and to better understand when each operation is called, I added for each operation a &lt;code class=&quot;highlighter-rouge&quot;&gt;printk(‚Äú‚Ä¶‚Ä¶.function name !‚Äù)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Module &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; and module &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After defining all the necessary operations, now we need to define the &lt;code class=&quot;highlighter-rouge&quot;&gt;module_init&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;module_exit&lt;/code&gt; functions. These two functions are the homologue of the &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; function in a regular program and they are as mandatory as the &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt; function is. The &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; function is the function that is called when the driver is loaded into the Linux kernel, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt; one is called when the driver is unloaded&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;module_init&lt;/code&gt; function we register our serial driver along with its port using &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_register_driver()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_add_one_port()&lt;/code&gt; functions:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init&lt;/span&gt;    &lt;span class=&quot;nf&quot;&gt;mymodule_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_register_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_ERR&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;softUart: could not register driver: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_add_one_port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_ERR&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;softUart: could not add port: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;uart_unregister_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Module initilized ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;module_exit&lt;/code&gt; we unregister the driver and its port in the reverse order of registering: first unregistering the port and then the driver.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__exit&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mymodule_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;uart_remove_one_port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;uart_unregister_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softUart_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Bye. &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;compilation&quot;&gt;Compilation&lt;/h3&gt;

&lt;p&gt;To compile our Linux module, we need to have on our system the Linux headers of the kernel on which the module will run. These headers provide the various function and structure definitions required when compiling code that interfaces with the kernel. If you are using a &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; executing the latest Raspbian image with internet access for development, the command below is sufficient to get the headers for your Linux kernel version:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo apt-get install raspberrypi-kernel-headers&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In my case, as my &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; doesn‚Äôt execute the latest Raspbian image, the command above gave me a much recent kernel headers version which is not compatible with my kernel version, so i had to install it manually. (if you want to find out your image kernel version, execute the command: &lt;code class=&quot;highlighter-rouge&quot;&gt;$ uname -a&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;The trick I used to get the proper Linux kernel headers version, is by searching in the Debian archive repository &lt;a href=&quot;http://archive.raspberrypi.org/debian/pool/main/r/raspberrypi-firmware/&quot;&gt;http://archive.raspberrypi.org/debian/pool/main/r/raspberrypi-firmware/&lt;/a&gt; for all the previous versions of the &lt;code class=&quot;highlighter-rouge&quot;&gt;raspberrypi-kernel-headers&lt;/code&gt; package and download the one corresponding to my kernel version. Remembering the time I downloaded the Raspbian image, made it really easy to guess which package is the one, as each package has a publication date. Packages in the archive are disposed as &lt;code class=&quot;highlighter-rouge&quot;&gt;deb&lt;/code&gt; files and can be installed using the command below:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo dpkg -i raspberrypi-kernel-headers_&amp;lt;pack-version&amp;gt;_armhf.deb&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Note&lt;/em&gt; : if you can‚Äôt remember the date your image came out , you can install the packages one by one until you find the proper version. The package manager will automatically downgrade when you install older versions (the installed headers can be found under /usr/src/ folder).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;After we got the Linux headers, we can now compile our module using the &lt;code class=&quot;highlighter-rouge&quot;&gt;makefile&lt;/code&gt; below:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;obj-m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; Mymod.o
 &lt;span class=&quot;nv&quot;&gt;Mymod-objs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; circular_buffer.o soft_uart.o module.o
 &lt;span class=&quot;nv&quot;&gt;RELEASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shell&lt;/span&gt; uname &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;LINUX_HEADERS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /usr/src/linux-headers-&lt;span class=&quot;nv&quot;&gt;$(RELEASE)&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;$(MAKE)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(LINUX_HEADERS)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(PWD)&lt;/span&gt; modules
 &lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;$(MAKE)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$(LINUX_HEADERS)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(PWD)&lt;/span&gt; clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;where the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;LINUX_HEADERS&lt;/code&gt; points to the path of the Linux headers.&lt;/p&gt;

&lt;p&gt;After successful compilation we obtain a file with the extension &lt;code class=&quot;highlighter-rouge&quot;&gt;.ko&lt;/code&gt; (kernel object) which corresponds to our module object. To load the module into the kernel we use the command below:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ insmod Mymod.ko&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If we check now under the &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt; path we can find that our serial port appears as a &lt;code class=&quot;highlighter-rouge&quot;&gt;TTY&lt;/code&gt; device named &lt;strong&gt;ttySOFT0&lt;/strong&gt; indicating a successful registration of our driver under the &lt;code class=&quot;highlighter-rouge&quot;&gt;TTY&lt;/code&gt; subsystem of the kernel.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post2/clip_image004.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post2/clip_image006.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The figure below shows the first test of our driver. I used a serial/usb adapter to connect to the Raspberry ports &lt;code class=&quot;highlighter-rouge&quot;&gt;17&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;27&lt;/code&gt;, via the &lt;code class=&quot;highlighter-rouge&quot;&gt;minicom&lt;/code&gt; console:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post2/clip_image008.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, our &lt;code class=&quot;highlighter-rouge&quot;&gt;SoftUART&lt;/code&gt; driver is working properly in both Tx and Rx modes. As of the baudrate, the max allowed value for proper functioning of the driver was found to be 19200, beyond this baudrate, all exchanged data are corrupted.&lt;/p&gt;

&lt;p&gt;This limitation is well expected: a rise in the baudrate will tighten the timing constraints on our system and will end up by exceeding its capabilities as our implementation is prone to a lot of preemption. However, if we limit our baudrate below the max value, no difference can be noticed compared to a hardware peripheral.&lt;/p&gt;

&lt;h3 id=&quot;serial-line-internet-protocol&quot;&gt;Serial Line Internet Protocol&lt;/h3&gt;

&lt;p&gt;Coming soon‚Ä¶&lt;/p&gt;

&lt;p&gt;A.L&lt;/p&gt;

&lt;h3 id=&quot;r√©f√©rences&quot;&gt;R√©f√©rences&lt;/h3&gt;

&lt;p&gt;Low Level Serial API : &lt;a href=&quot;https://www.kernel.org/doc/Documentation/serial/driver&quot;&gt;https://www.kernel.org/doc/Documentation/serial/driver&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chapter 18. TTY Drivers : &lt;a href=&quot;https://www.oreilly.com/library/view/linux-devicedrivers/0596005903/ch18.html&quot;&gt;https://www.oreilly.com/library/view/linux-devicedrivers/0596005903/ch18.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Linux TTY driver‚ÄìUart_driver bottom layer : &lt;a href=&quot;https://blog.csdn.net/sharecode/article/details/9196591&quot;&gt;https://blog.csdn.net/sharecode/article/details/9196591&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Linux uart underlying device driver detailed : &lt;a href=&quot;https://blog.csdn.net/weixin_38696651/article/details/89431600&quot;&gt;https://blog.csdn.net/weixin_38696651/article/details/89431600&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A preliminary study of tty-analysis of uart driver framework : &lt;a href=&quot;https://blog.csdn.net/lizuobin2/article/details/51773305/&quot;&gt;https://blog.csdn.net/lizuobin2/article/details/51773305/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Sep 2020 18:24:03 +0200</pubDate>
        <link>https://lakabd.github.io/linux-driver/2020/09/29/post-2.html</link>
        <guid isPermaLink="true">https://lakabd.github.io/linux-driver/2020/09/29/post-2.html</guid>
        
        
        <category>linux-driver</category>
        
      </item>
    
      <item>
        <title>Linux kernel module : Building a soft UART for the Raspberry Pi - part1</title>
        <description>&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; is a well-known platform intended for educational use. For its compact form and relatively low cost, this board has become very popular among enthusiasts and makers. The &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; is used in many projects from different fields, eg. &lt;code class=&quot;highlighter-rouge&quot;&gt;Robotics&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;IoT&lt;/code&gt;‚Ä¶ where it‚Äôs linked with different types of sensors and detectors.
&lt;!--end_excerpt--&gt;&lt;/p&gt;

&lt;p&gt;In many cases, the sensors that are used, adopts a communication protocol such as &lt;code class=&quot;highlighter-rouge&quot;&gt;SPI, UART, I2C&lt;/code&gt; for wired communication, or wireless using protocols such as &lt;code class=&quot;highlighter-rouge&quot;&gt;Bluetooth&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ZigBee&lt;/code&gt;. The most adopted, and easy to use of serial protocols is the Universal Asynchronous Receiver-Transmitter (&lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; for short).&lt;/p&gt;

&lt;p&gt;Unfortunately, all versions of the &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; until version 3, comes with &lt;a href=&quot;https://www.blogger.com/blog/post/edit/1828726825959781021/5433115005355325235&quot;&gt;only two UART ports&lt;/a&gt; : A full featured &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; (PL011) enabled by default (GPIO‚Äôs 14 and 15), and a mini &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; with a reduced feature set (used by the wireless LAN/Bluetooth controller, on models which contain this controller) that necessitate some tweaking to get it working at first (modification of the Device Tree Overlay basically). This hardware limitation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; can be a complication for projects that needs more than the two &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ports, especially for &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; models that doesn‚Äôt have much of peripherals (eg. &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt; Zero).&lt;/p&gt;

&lt;p&gt;The idea behind this project, comes to tackle this specific problem by creating a software &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; compatible with all Linux based boards including the &lt;code class=&quot;highlighter-rouge&quot;&gt;RPi&lt;/code&gt;. Because it‚Äôs a software implementation, it has only the minimal features required to establish a reliable serial connection. As you will find throughout this 2-parts write up, the software implementation obviously can‚Äôt compete with the real hardware port, nevertheless, it offers a decent alternative.&lt;/p&gt;

&lt;p&gt;You‚Äôll find all the written code in my &lt;strong&gt;&lt;a href=&quot;https://www.blogger.com/blog/post/edit/1828726825959781021/5433115005355325235&quot;&gt;Github&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;linux-driver&quot;&gt;Linux driver&lt;/h2&gt;

&lt;p&gt;Yes, I opted to implement this software &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; port inside the Linux kernel as a Linux driver (a.k.a Linux module). If you are not familiar with Linux modules, they simply consist of a chunk of code that runs inside the kernel space, basically to add useful features to the OS or support to some device or user app, and it can be loaded/unloaded into the Linux kernel at runtime. The advantage of Linux modules over the applications that runs in the user space, is that they have higher execution privilege and generally run‚Äôs faster than the user space apps. As we are trying to emulate a hardware protocol by software, speed of execution is a real concern for us, hence, the implementation as a Linux driver.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UART serial port&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Before starting the implementation of our driver, we need first to take a look at the inner working of the &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol.&lt;/p&gt;

&lt;p&gt;Below is a general summary of how the &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post1/clip_image001.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol is a two-wire protocol: transmit &lt;code class=&quot;highlighter-rouge&quot;&gt;Tx&lt;/code&gt; and receive &lt;code class=&quot;highlighter-rouge&quot;&gt;Rx&lt;/code&gt;, that lets two nodes exchange data asynchronously. To synchronize data sampling, the transmitter adds to each data word a start and a stop bit (the stop can be 1, 1.5 or 2 bits long), along with an optional parity bit that helps protecting the integrity of the data word.&lt;/p&gt;

&lt;p&gt;Each packet contains a data word that can be 5 to 9 bits long. When the receiver detects the start bit in the Rx line, it starts sampling the data at the frequency specified by the baudrate (bits/sec). Additionally, advanced &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt;‚Äôs implements a hardware flow control (HFC) which is basically a strategy for communication between slow and fast devices without data loses.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; is a very simple protocol, however, its software emulation rises some exclamation marks about software preemption and the execution speed. As a matter of fact, like all other programs that runs on the processor, our Linux driver will obey to the scheduling policy of the Linux OS and depending on the baudrate used, the &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol can impose very strict timing constraints: Each bit that is transmitted via the Tx line, takes &lt;code class=&quot;highlighter-rouge&quot;&gt;1/baudrate&lt;/code&gt; seconds to be sent. Therefore, if we consider that the receiver samples the data bits exactly at the middle, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/(2*baudrate)&lt;/code&gt; will correspond to the maximum allowed difference between the sender‚Äôs and the receiver‚Äôs baudrates, e.g. for a baudrate of &lt;code class=&quot;highlighter-rouge&quot;&gt;9600&lt;/code&gt;, the max allowed difference between the two baudrates is &lt;code class=&quot;highlighter-rouge&quot;&gt;~52 Œºs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a consequence, to avoid preemption and speed problems, in our implementation we will try to minimize all critical parts in the code and we will consider only the following minimal feature set of the protocol:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data word size of 8bits.&lt;/li&gt;
  &lt;li&gt;1 start and 1 stop bit.&lt;/li&gt;
  &lt;li&gt;No parity bit.&lt;/li&gt;
  &lt;li&gt;No flow control.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;What is a Linux TTY driver?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The name of &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; devices came from the old abbreviation &lt;em&gt;Teletype (writer)&lt;/em&gt;, and it is commonly associated with serial devices. For a serial port to be properly integrated under the Linux kernel, it must be visible as a &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; device from the user space, and for that, any serial driver must be implemented in the &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; kernel subsystem.&lt;/p&gt;

&lt;p&gt;The figure below, shows the implementation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; subsystem under the Linux kernel:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post1/clip_image003.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;tty core&lt;/em&gt;&lt;/strong&gt; driver is implemented as a character driver under the Linux kernel, and it offers a set of functionalities that serves as an interface for serial devices. This driver is responsible of controlling both the data flow and the format of packets passing through it, allowing serial drivers to focus on the low-level hardware interactions instead of worrying about data exchanges with the user space. In addition, &lt;strong&gt;&lt;em&gt;tty core&lt;/em&gt;&lt;/strong&gt; include a set of extensions called ‚Äòlines of discipline‚Äô that mounts between the &lt;strong&gt;&lt;em&gt;tty core&lt;/em&gt;&lt;/strong&gt; and the serial driver enabling extended functionalities to the serial driver (by default, &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; core uses &lt;code class=&quot;highlighter-rouge&quot;&gt;ldscp N_TTY&lt;/code&gt; which directly link the serial driver to the user space).&lt;/p&gt;

&lt;p&gt;Until version 2.6 of the Linux kernel, serial drivers were implemented directly under the &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; core driver inheriting a non-negligible complexity for the driver development. However, since version 2.6, a new interface, &lt;strong&gt;&lt;em&gt;serial core&lt;/em&gt;&lt;/strong&gt;, was implemented under the &lt;strong&gt;&lt;em&gt;tty core&lt;/em&gt;&lt;/strong&gt; to ease the development of serial drivers.&lt;/p&gt;

&lt;p&gt;In this project we will implement our driver under the &lt;strong&gt;&lt;em&gt;serial core&lt;/em&gt;&lt;/strong&gt; interface, but before that, one of course must have a functional and structural understanding of the APIs offered by this interface and how interactions with the low-level operations Tx &amp;amp; Rx are implemented. For that, one needs to analyze the source code of the interface: &lt;code class=&quot;highlighter-rouge&quot;&gt;/linux/serial_core.h&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;After thorough analysis, in the diagram below I show the important structural links of &lt;strong&gt;&lt;em&gt;serial core&lt;/em&gt;&lt;/strong&gt; with the top layer &lt;strong&gt;&lt;em&gt;tty core&lt;/em&gt;&lt;/strong&gt; and the low-level layer:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post1/clip_image004.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In fact, the use of &lt;strong&gt;&lt;em&gt;serial core&lt;/em&gt;&lt;/strong&gt; interface needs the definition of three main structures:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The structure representing the driver: &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_driver&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The structure representing the port included in the driver: &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The structure containing the pointers to the port operations: &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_ops&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other structures are automatically initialized when the driver is registered on the kernel, and they must not be defined by the user e.g. &lt;em&gt;tty_driver&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;For organization purposes, (As we ‚Äì informaticians ‚Äì like to split things into layers) the implementation of the driver will be separated in two halves:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post1/clip_image006.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A bottom half that contains the &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol implementation and manages the low level &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; interactions.&lt;/li&gt;
  &lt;li&gt;A top half which implements the actual &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; driver and manages the interaction with the user space.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before creating the code for the two layers, we first need to have some sort of &lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt; memory to store received and to-send data. For this purpose, we decided to implement a circular buffer that will manage data exchanges between the two layers of the driver. Also, this type of buffer allows an efficient use of the fixed buffer size.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post1/clip_image008.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A circular buffer is characterized by two pointers that manages the read/write operations: a &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; pointer, always pointing to the top of the buffer (address of the next write), and a &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; pointer that always points to the last element of the buffer (address of the next read).&lt;/p&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;circular_buffer.h&lt;/code&gt; we will create the structure of our circular buffer which include the two pointers &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;, a fixed size data buffer (of type &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;) plus a flag to indicate the status of our buffer:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isfull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUFFER_MAX_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There will be two instantiations of this buffer: &lt;code class=&quot;highlighter-rouge&quot;&gt;rx_buffer&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tx_buffer&lt;/code&gt; so that data exchanges can be managed separately between the two halves of the driver.&lt;/p&gt;

&lt;p&gt;In addition, we will define some basic functions that eases buffer manipulations:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; function that resets the buffer pointers to zero:
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initialize_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Functions to read and write one char into the buffer:
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push_character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pull_character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;after each write (read) the &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;) pointer is incremented. This modification of the two pointers is implemented carefully following the circular buffer algorithm.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Functions to get the status of the buffer:
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isBufferFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isBufferEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;bottom-half&quot;&gt;Bottom half&lt;/h4&gt;

&lt;p&gt;Now, let‚Äôs start our implementation of the low-level &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; protocol. To make things more fun, I drew the state diagram below to sum up our implementation. As it‚Äôs only a half-duplex protocol, our code will have only one function to execute at a time: write or read.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/post1/clip_image010.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In a new file &lt;code class=&quot;highlighter-rouge&quot;&gt;soft_uart.c&lt;/code&gt; we start the definition of our main functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INIT_fct&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first function is the &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; function, in which we start by initializing the Rx and Tx buffers, the &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; pins (&lt;em&gt;note&lt;/em&gt; : the idle state of the Tx pin is high), and we reserve the Rx line interrupt to be able to start receiving data (in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ISR&lt;/code&gt;) asap. We initialize also a reception &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt; that is used to pass Rx data over to the top layer (this will be discussed further below).&lt;/p&gt;

&lt;p&gt;This function takes in parameters the &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; pin number of both Tx and Rx (in our implementation we used pins &lt;code class=&quot;highlighter-rouge&quot;&gt;17&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;27&lt;/code&gt; respectively), in addition, it takes a pointer to the serial port structure &lt;code class=&quot;highlighter-rouge&quot;&gt;struct uart_port&lt;/code&gt; which is handed over to the receiving &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the baudrate, we will set it as a global variable so it can be accessed by all functions of the driver.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;uart_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*Initilize buffers*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;initialize_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;initialize_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
&lt;span class=&quot;cm&quot;&gt;/*Initialize the GPIO pins.*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gpio_request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;uart_tx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio not reserved : %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gpio_direction_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio direction not set : %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gpio_request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;uart_tx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio not reserved : %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gpio_direction_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gpio direction not set : %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    
&lt;span class=&quot;cm&quot;&gt;/*Initialize interrupt: rx trigger*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_to_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;irq_handler_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_rx_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRQF_TRIGGE&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;R_FALLING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Rx_handler&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_WARNING&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;irq request error : %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_INFO&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;irq requested succesfully ! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
&lt;span class=&quot;cm&quot;&gt;/*rx_tasklet init*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tasklet_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_tasklet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx_tasklet_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Tx_fct&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The transmit function is implemented as a simple while loop in which we retrieve data ‚Äì word by word ‚Äì from the Tx_buffer and send it bit per bit, along with a start bit at the beginning and a stop bit at the end of each data word.&lt;/p&gt;

&lt;p&gt;To respect the baudrate, we will implement a delay after each bit that is sent using the &lt;code class=&quot;highlighter-rouge&quot;&gt;ndelay()&lt;/code&gt; function (nano-second delay). In addition, at the end of transmission, we call the &lt;code class=&quot;highlighter-rouge&quot;&gt;uart_write_wakeup()&lt;/code&gt; function to wake up the upper layers and trigger the next transmission.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;uart_handle_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*send wakeup to tty layer to begin next write*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uart_write_wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*send data*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pull_character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//startbit
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//data bits
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//stop bit
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;gpio_set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//statistics : increment port tx count
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;icount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We‚Äôve used the &lt;code class=&quot;highlighter-rouge&quot;&gt;ndelay()&lt;/code&gt; function instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;htimer&lt;/code&gt; (which is a high resolution timer used in time precision based events) because the costs of frequently enabling and disabling &lt;code class=&quot;highlighter-rouge&quot;&gt;htimers&lt;/code&gt;, in our use case, was experimentally judged of more harm than good (compared to using the &lt;code class=&quot;highlighter-rouge&quot;&gt;*delay()&lt;/code&gt; function family) especially for high baudrate values.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rx_fct&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The implementation of the receive function is divided in two parts: the first part, which is the critical one, directly implemented in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ISR&lt;/code&gt; of the Rx line and handles the sampling of the received bits, and a second part, implemented in a &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt;, responsible of passing the received data over to the top layer.&lt;/p&gt;

&lt;p&gt;During the critical sampling part, for the interrupt to not be triggered by the data bits and scheduled by the system (the IT must only be triggered by the start bit), we must momentarily disable it using the &lt;code class=&quot;highlighter-rouge&quot;&gt;disable_irq_nosync()&lt;/code&gt; function. The interrupt is reenabled after the reception of one data word. At the end, each data word is stored in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rx_buffer&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rx_tasklet&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;Once again, we add nano delays between bits reception clocking out the sampling frequency. However, this time, we add a &lt;code class=&quot;highlighter-rouge&quot;&gt;¬º baudrate&lt;/code&gt; time before the first sample to avoid sampling at the edge (not &lt;code class=&quot;highlighter-rouge&quot;&gt;¬Ω&lt;/code&gt; - sampling at the halfway point ‚Äì to increase our jitter acceptance margin), also the reception of the start and stop bits is ignored using a dummy delay.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;irqreturn_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;uart_handle_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;disable_irq_nosync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*disable the interrupt, so it&#39;s not triggered by the data bits*/&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//start bit
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*adding 1/4 offset time to avoid sampling at the edge. Not 1/2 (sampling at the halfwaypoint), so we can increase our jitter acceptance margin, as we are more likely to sample slower not faster than the baudrate.*/&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//data
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_get_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//stop bit
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ndelay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_interval_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*reenable the interrupt*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;enable_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*push_character to rx_buffer*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;push_character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*schedule tasklet*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tasklet_schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_tasklet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*reinitialize receive char*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;receive_char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&#39;\0&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRQ_HANDLED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In contrary to what their name implies, &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklets&lt;/code&gt; are not small tasks/threads, they are simply a mechanism that allows &lt;code class=&quot;highlighter-rouge&quot;&gt;ISRs&lt;/code&gt; to execute a non-critical portion of the code outside its context. The &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt; is executed asap after the &lt;code class=&quot;highlighter-rouge&quot;&gt;ISR&lt;/code&gt; is ended. Yet, only one call to the &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt; can be scheduled, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt; is called a second time, only one instance is executed. In our case we implemented a while loop inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;Rx_tsaklet&lt;/code&gt; function in which we read data continually from the &lt;code class=&quot;highlighter-rouge&quot;&gt;rx_buffer&lt;/code&gt; and send it up to the top layer.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rx_tasklet_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uart_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pull_character&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;cm&quot;&gt;/*insert char inside the serial_core with the appropriate flag*/&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;uart_insert_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TTY_NORMAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*the flag is always TTY_NORMAL as we don‚Äôt implement any error checking*/&lt;/span&gt;
	&lt;span class=&quot;cm&quot;&gt;/*statistics*/&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;icount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;cm&quot;&gt;/*when done with insertion, send data to tty layer*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tty_flip_buffer_push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Close_fct&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lastly, we implement the close function to properly free the used resources:  free &lt;code class=&quot;highlighter-rouge&quot;&gt;IRQ&lt;/code&gt; + free &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIOs&lt;/code&gt; + kill any scheduled &lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;uart_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*free IRQ*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;free_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_to_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*free gpio*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gpio_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gpio_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpio_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*kill rx tasklet*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tasklet_kill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_tasklet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At the end of the implementation we can test our code by registering it directly as a simple module (not &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt;) and verify the correctness of the output using a logic analyzer or simply connecting the &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; pins 17 &amp;amp; 27 to the ports of a usb/serial adapter. Feel free to test this part yourself.&lt;/p&gt;

&lt;p&gt;For me, I think we are done with this first part, long part, I will implement the top half of the driver in the part2 of this write-up. Also, for the testing part, we will see a real test of the driver in a Serial Line Internet Protocol (&lt;code class=&quot;highlighter-rouge&quot;&gt;SLIP&lt;/code&gt;), all of that until the driver is complete.&lt;/p&gt;

&lt;p&gt;See you in the next part.&lt;/p&gt;

&lt;p&gt;A.L&lt;/p&gt;

&lt;h3 id=&quot;r√©f√©rences&quot;&gt;R√©f√©rences&lt;/h3&gt;

&lt;p&gt;Raspberry Pi uarts : &lt;a href=&quot;https://www.raspberrypi.org/documentation/configuration/uart.md&quot;&gt;https://www.raspberrypi.org/documentation/configuration/uart.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Timing Errors in Serial Communication: &lt;a href=&quot;http://www.robotroom.com/Asynchronous-SerialCommunication-2.html&quot;&gt;http://www.robotroom.com/Asynchronous-SerialCommunication-2.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Linux serial driver : &lt;a href=&quot;https://bootlin.com/doc/legacy/serial-drivers/linux-serial-drivers.pdf&quot;&gt;https://bootlin.com/doc/legacy/serial-drivers/linux-serial-drivers.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chapter 18. TTY Drivers : &lt;a href=&quot;https://www.oreilly.com/library/view/linux-devicedrivers/0596005903/ch18.html&quot;&gt;https://www.oreilly.com/library/view/linux-devicedrivers/0596005903/ch18.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Sep 2020 17:44:54 +0200</pubDate>
        <link>https://lakabd.github.io/linux-driver/2020/09/10/post-1.html</link>
        <guid isPermaLink="true">https://lakabd.github.io/linux-driver/2020/09/10/post-1.html</guid>
        
        
        <category>linux-driver</category>
        
      </item>
    
  </channel>
</rss>
