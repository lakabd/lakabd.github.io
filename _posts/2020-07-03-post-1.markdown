---
layout: post
title:  "Linux kernel driver : Building a soft UART for Raspberry Pi boards"
date:   2020-07-03 17:44:54 +0200
categories: Embedded
---

The RPi is a well known platform intended for educational use. For its compact form and relatively low cost, this board has become very popular among enthusiasts and makers. The RPi is used in many projects from different fields, eg. robotics and IoT... where it's linked with different types of sensors and detectors.

In many cases, the sensors that are used, adopts a communication protocol such as SPI, UART, I2C for wired communication, or wireless using protocols such as Bluetooth and ZigBee. The most adopted, and easy to use of serial protocols is the Universal Asynchronous Receiver-Transmitter (UART for short).

Unfortunately, all versions of the RPi until version 3, comes with only two UART ports : a full featured UART (PL011) enabled by default (GPIO's 14 and 15), and a mini UART with a reduced feature set (used by the wireless LAN/Bluetooth controller, on models which contain this controller) that necessitate some tweaking to get it working at first (modification of the Device Tree Overlay basically). This hardware limitation of the RPi can be a complication for projects that needs more than the two UART ports especially for RPi models that doesn't have much of peripherals (eg. RPi Zero).

The idea behind this project, comes to tackle this specific problem by creating a software UART compatible with all linux based boards including the RPi. Because it's a software implementation, it has only the minimal features required to establish a reliable serial connection. As you will find throughout this write up, the software implementation obviously can't compete with the real hardware port, nevertheless, it offers a decent alternative.

You'ill find all the writen code in my Github.

# Driver development
Yes, I opted to implement this software UART port inside the Linux kernel as a Linux driver (a.k.a Linux module). If you are not familiar with Linux modules, they simply consist of a chunk of code that runs inside the kernel space, basically to add useful features to the OS or support to some device or user app, and it can be loaded/unloaded into the Linux kernel at runtime. The advantage of Linux modules over the applications that runs in the user space, is that they have higher execution privilege and generally run's faster than the user space apps. As we are trying to emulate a hardware protocol by software, speed of execution is a real concerne for us, hence, the implementation as a Linux driver.

Before starting the implementation of our driver, we need first to take a look at the inner working of the UART protocol. 
Bellow is a general summary of how the UART protocol works.
UART serial port


The UART protocol is a two wire protocol : transmit (Tx) and receive (Rx), that lets two nodes exchange data asynchronously. To synchronize data sampling, the transmitter adds to each data word a start and a stop bit (the stop can be 1, 1.5 or 2 bits long), along with an optional parity bit that helps protecting the integrity of the data word.

Each packet contains a data word that can be 5 to 9 bits long. When the receiver detects the start bit in the Rx line, it starts sampling the data at the frequency specified by the baudrate (bits/sec). Additionally, advanced UART's implements a hardware flow control (HFC) which is basically a strategy  for the communication between slow and fast devices without losing data.
UART is a very simple protocol, however, its software emulation rises some exclamation marks about software preemption and the execution speed. As a matter of fact, like all other programs that runs on the processor, our Linux driver will obey to the scheduling policy of the Linux OS and depending on the baudrate used, the UART protocol can impose some very strict timing constraints : Each bit that is transmitted via the Tx line, takes 1/baudrate secondes to be sent. Therefore, if we consider that the receiver samples the data bits exactly at the middle, 1/(2*baudrate) will correspond to the maximum allowed difference between the sender's and the receiver's baudrates, eg. for a baudrate of  9600, the max allowed difference between the two baudrates is ~52 Î¼s.

As a consequence, to avoid preemption and speed problems, in our implementation we will try to minimalize all the critical parts in the code and we will consider only the following minimale feature set of the protocol : 

- Data word size of 8bits.
- 1 start and 1 stop bit.
- No parity bit.
- No flow control.

## Implementation
The implementation of the driver will be separated in two halves :
       
A bottom half that contains the protocol implementation and manages the low level GPIO interactions.
A top half which implements the actual TTY driver and manages the interaction with the user space.
### Bottom half
For the is section, before creating the code that manages the low level interactions, we will start by implementing a circular buffer that will be used to stock the sending data. This buffer will be shared between the function that reads













to be continued...





A.L
