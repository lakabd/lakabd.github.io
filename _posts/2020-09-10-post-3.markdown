---
layout: post
title:  "Projet YOCTO : Build dâ€™une image Linux-RT pour Beaglebone Black"
date:   2020-09-10 15:14:45 +0200
language: FR
categories: linux-driver
excerpt_separator: <!--end_excerpt-->
---

La carte Beaglbone black (`BBB`) est une plateforme embarquÃ©e open source utilisÃ©e dans plusieurs domaines Ã©ducationnels ainsi quâ€™industriels. EquipÃ©e dâ€™un `SOC` am533x de Texas Instrument, cette plateforme est capable de tourner diffÃ©rents systÃ¨mes dâ€™exploitation comme Linux, Android, WinCEâ€¦ 
<!--end_excerpt-->

Dans certaines applications, notamment dans le domaine industriel, il est parfois exigÃ© dâ€™avoir une performance temps rÃ©el du system, ce qui nÃ©cessite lâ€™utilisation dâ€™une solution temps rÃ©el soit software ou hardware. Dans ce manuscrit, nous allons sâ€™intÃ©resser Ã  une solution software open source dÃ©diÃ©e au system Linux connue sous le nom : le projet `PREEMPT_RT`.

> "Controlling a laser with Linux is crazy, but everyone in this room is crazy in his own way. So, if you want to use Linux to control an industrial welding laser, I have no problem with your using PREEMPT_RT." -- Linus Torvalds

Le projet `PREEMPT_RT` (fondÃ© et maintenu par Thomas Gleixner, Ingo Molnar et de nombreux autres collaborateurs) offre une solution temps rÃ©el Â« souple Â» qui se prÃ©sente sous forme dâ€™un patch quâ€™on peut appliquer sur un noyau Linux standard pour amÃ©liorer ses performances pour le temps rÃ©el. Lâ€™application du patch `PREEMPT_RT` se fait sur le code source dâ€™un noyau Linux avant sa compilation. Toutefois, comme le patch nâ€™est disponible que pour des versions majeures et mineures bien prÃ©cises du noyau Linux standard, lâ€™application du patch peut sâ€™avÃ©rer dâ€™une grande complexitÃ© Ã  cause des problÃ¨mes de compatibilitÃ©.

Lâ€™objectif de cet article est dâ€™investiguer une technique automatisÃ©e de construction dâ€™image Linux embarquÃ© avec le fameux projet Yocto, en construisant une image Linux patchÃ©e avec `PREEMPT_RT` pour la cible `BBB`. Dans La premiÃ¨re partie, une introduction au systÃ¨me de construction du projet Yocto et de ses importants outils est prÃ©sentÃ©e. Dans la deuxiÃ¨me partie, nous allons voir la configuration rÃ©alisÃ©e pour la construction dâ€™une image Linux-RT basÃ©e sur un noyau fourni par Texas Instrument, puis, nous concluons par faire une comparaison de la performance offerte par cette solution temps rÃ©el, par rapport Ã  une implÃ©mentation Linux normal. 

 

## Projet Yocto

Le projet Yocto est un projet collaboratif, open source, crÃ©Ã© par la fondation Linux en 2011 avec lâ€™objectif de fournir et de crÃ©er des outils et processus interopÃ©rables pour la construction des images Linux personnalisÃ©es dÃ©diÃ©es aux systÃ¨mes embarquÃ©s et IoT, peut-import leurs architectures hardware. Le projet Yocto offre un environnement de dÃ©veloppement flexible, qui permet aux dÃ©veloppeurs de systÃ¨mes embarquÃ©s de collaborer Ã  travers une technologie partagÃ©e de piles logicielles, de configurations et des meilleures pratiques utilisÃ©es pour crÃ©er des images Linux personnalisÃ©es.

Ce projet est basÃ© sur une plateforme appelÃ©e `OpenEmbedded` crÃ©Ã©e en 2003, qui est une plateforme de compilation croisÃ©e automatisÃ©e, dÃ©diÃ©e Ã  la construction des images Linux embarquÃ©e. Le system de construction de cette plateforme utilise un outil qui sâ€™appelle `Bitbake`, similaire Ã  lâ€™outil `GNU Make`, et qui permet de spÃ©cifier les scriptes de construction, appelÃ©e Â« recettes Â» dans le langage `Bitbake`, dâ€™un package donnÃ©. Les recettes `Bitbake` (extension `.bb`) incluent la liste des dÃ©pendances de chaque package, la location du source code, et toutes autres informations nÃ©cessaires qui permettent aux outils `dâ€™OpenEmbedded` de crÃ©er une image Linux bootable.

Dans la repos officielle ( ðŸ•Š j'ai l'habitude d'utiliser le mot "la repos" Ã  la place de " le dÃ©pÃ´t" conformÃ©ment au mot anglais dominant : Repository ) du projet Yocto : git.yoctoproject.org, nous trouvons une distribution de rÃ©fÃ©rence appelÃ©e `Poky`, qui contient le systÃ¨me de construction `OpenEmbedded` plus un ensemble de mÃ©tadonnÃ©es permettant aux dÃ©veloppeurs dâ€™amorcer la construction de leurs distributions personnalisÃ©es. Cette rÃ©fÃ©rence est fournie comme une spÃ©cification de base et elle permet - out of the box - de construire une image bootable pour un systÃ¨me embarquÃ© typique.

La figure ci-dessous illustre la relation de `Poky` avec le reste du projet :

![image-20201108170016427](/media/post3/image-20201108170005870.png)

Pour en savoir plus sur `Poky`, voir le lien : [Reference Embedded Distribution (Poky)](https://www.yoctoproject.org/docs/2.5/overview-manual/overview-manual.html#reference-embedded-distribution)

### ModÃ¨le en couche

Lâ€™un des points forts du projet Yocto et que chaque aspect de construction est contrÃ´lÃ© via les mÃ©tadonnÃ©es. En effet, Il est possible dâ€™ajouter/modifier des couches de mÃ©tadonnÃ©es permettant lâ€™ajout de nouvelles piles logicielles, du support pour le nouveau hardware (Board Support Packages) ou mÃªme crÃ©er des nouveaux types dâ€™images (image minimale, basiqueâ€¦).

Le modÃ¨le en couche du projet Yocto sert Ã  isoler les diffÃ©rentes personnalisations ajoutÃ©es, dans le but dâ€™amÃ©liorer la flexibilitÃ© et la rÃ©utilisabilitÃ© de ses diffÃ©rents processus de construction : plus la structure est modulaire plus et facile de coopÃ©rer avec les changements futurs.

Chaque couche Yocto respecte une hiÃ©rarchie bien prÃ©cise, permettant de garder la compatibilitÃ© et la portabilitÃ© avec les autres couches du projet. Par commoditÃ© dâ€™utilisation, le nom des couches Yocto commence toujours par le prÃ©fix `meta-` . Ci-dessous, la composition typique dâ€™une couche Yocto : 

![image-20201108170028468](/media/post3/image-20201108170028468.png)

Une couche Yocto est composÃ©e dâ€™un dossier obligatoire conf qui contient :

- Le fichier de configuration `layer.conf` indiquant les diffÃ©rentes recettes offertes par cette couche.

- Le dossier machine qui contient le fichier de configuration `machine.conf` liÃ©e Ã  la plateforme cible. 

Plus des dossiers de recettes qui ajoutent le support de nouvelles fonctionnalitÃ©s, ou Ã©tendent (fichiers `.bbappend`) celles existantes dÃ©jÃ  dans autres couches. Dans la couche de la figure ci-dessus, nous trouvons, en plus du conf, le dossier `recipes-kernel` qui contient une recette `Bitbake` (.bb) pour la construction dâ€™un noyau Linux.

#### Couche BSP

En effet, les couches Yocto qui ajoutent du support Ã  des nouvelles machines sont appelÃ©es des couches `BSP` (Board Support Packages). Il sâ€™agit dâ€™une collection dâ€™instructions et dâ€™informations (des mÃ©tadonnÃ©es) qui dÃ©finit comment prendre en charge un systÃ¨me ou pÃ©riphÃ©rique matÃ©riel. Elles incluent des informations sur les fonctionnalitÃ©s matÃ©rielles prÃ©sentes sur le pÃ©riphÃ©rique, les informations de configuration du noyau ainsi que tout pilote matÃ©riel supplÃ©mentaire requis. Elles ajoutent Ã©galement tous les composants logiciels supplÃ©mentaires en addition au stack Linux, pour les fonctionnalitÃ©s du pÃ©riphÃ©rique essentielles et facultatives.

### Bitbake

`BitBake` se trouve au cÅ“ur du systÃ¨me de build `OpenEmbedded`. Câ€™est un systÃ¨me gÃ©nÃ©rique d'exÃ©cution de tÃ¢ches (Ã©crit en `Python`), qui permet aux tÃ¢ches `shell` et `Python` d'Ãªtre exÃ©cutÃ©es efficacement et en parallÃ¨le tout en travaillant dans des contraintes de dÃ©pendance inter-tÃ¢ches complexes.

Conceptuellement, `BitBake` est similaire Ã  `GNU Make` Ã  certains Ã©gards :

- `BitBake` exÃ©cute les tÃ¢ches en fonction des mÃ©tadonnÃ©es fournies de chaque package. Les mÃ©tadonnÃ©es sont stockÃ©es dans les fichiers recettes (`.bb`), fichiers de configuration (`.conf`) et de classe (`.bbclass`) qui fournissent Ã  `BitBake` toutes les instructions sur les tÃ¢ches Ã  exÃ©cuter et leurs interdÃ©pendances.

- `BitBake` inclut toute une bibliothÃ¨que dÃ©dier Ã  la rÃ©cupÃ©ration du code source de divers endroits (systÃ¨mes de contrÃ´le de source, serveurs Web,â€¦) et qui supporte plusieurs protocoles : git, https, ftp, file, sshâ€¦

- `Bitbake` utilise un model client/serveur, qui permet de lâ€™utiliser Ã  partir de la ligne de commande ou comme un service via XML-RPC.

#### Les recettes Bitbake :

Ce sont des fichiers dÃ©signÃ©s par l'extension `.bb`, et ils reprÃ©sentent les briques Ã©lÃ©mentaires des mÃ©tadonnÃ©es. Chaque fichier recette, fournit toutes les informations nÃ©cessaires Ã  la construction du package correspondant. Ces informations sont organisÃ©es dans des variables ou codÃ©es dans des fonctions prÃ©dÃ©finies par `Bitbake` :

- Une description du package : Dans la variable `DESCRIPTION`.

- La version de la recette : Dans la variable `PV`.

- Les dÃ©pendances existantes : Dans la variable `DEPENDS`.

- La location du source code du package : Dans la variable `SRC_URI`.

- La location des diffÃ©rents patches Ã  appliquer au code source, sâ€™il y en existe : Dans la variable `SRC_URI`.

- Comment configurer et compiler le code source : Dans les fonction `do_configure()` et `do_compile()`

- OÃ¹ installer le package : Dans la fonction `do_install()`

En addition, les recettes `Bitbake` utilisent une convention de nommage standard qui inclut le nom du package plus sa version dans le nom de la recette. Câ€™est une rÃ¨gle de nommage Ã  respecter, comme ces valeurs sont automatiquement prises par `Bitbake` et lui permet de localiser toutes les recettes disponibles et leurs versions correspondantes. Le format attendu du nom dâ€™une recette est le suivant : `packagename_version-r1.bb` avec `r1` le numÃ©ro du release (sâ€™il nâ€™est pas spÃ©cifiÃ©, sa valeur par dÃ©faut est `r0`). Par exemple, dans la couche Yocto de la figure prÃ©cÃ©dente, nous avions une recette pour la construction dâ€™un package `linux-yocto` de version `5.4`. 

> Note : Pour choisir cette recette dans le build dâ€™une machine, au cas oÃ¹ il yâ€™en a plusieurs pour diffÃ©rentes versions, il suffit de spÃ©cifier dans le fichier `machine.conf` la version prÃ©fÃ©rÃ©e en utilisant la notation suivante :        `PREFERRED_VERSION_linux-yocto = "5.4"` 



## Construction dâ€™une image temps rÃ©el pour la BeagleBone Black

### PrÃ©paration du Workspace 

Pour utiliser le projet Yocto, il est nÃ©cessaire dâ€™abord dâ€™avoir une machine de dÃ©veloppement avec un minimum de 50 Go d'espace disque libre et qui exÃ©cute une distribution Linux prise en charge (voir le [lien](http://www.yoctoproject.org/docs/2.4.2/ref-manual/ref-manual.html#detailed-supported-distros)).

- Installation des packages essentiels :

Ce sont les principaux outils et packages nÃ©cessaires Ã  la construction avec le projet Yocto. Ceux-ci incluent le compilateur `GNU GCC`, un systÃ¨me de contrÃ´le de versions, plus d'autres packages selon ce quâ€™on veut faire (ajouter du support graphique, gÃ©nÃ©rer la doc â€¦ etc). Ci-dessous la commande pour obtenir l'essentiel sur Ubuntu :

```bash
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm
```

- RÃ©cupÃ©ration des couches de mÃ©tadonnÃ©es nÃ©cessaires :

Pour notre cible `BBB`, nous allons se baser sur la couche `Poky`, mais en plus, nous avons besoin de la couche `BSP` spÃ©cifique au hardware de la carte `BBB`. Pour cela nous allons utiliser la couche `meta-ti` de la part de Texas Instrument (qui est le vendeur du `SOC` amx335 de la carte `BBB`) fournie dans la repos officielle du projet Yocto. Dans cette couche, en plus des recettes `BSP` qui incluent les configurations hardwares, nous trouvons les recettes de construction des noyaux `Linux-rt` et `non-rt` fournies par TI ainsi que des recettes personnalisÃ©es avec des fonctionnalitÃ©s supplÃ©mentaires compatibles avec la carte `BBB`.

Nous avons besoin donc, de deux couches : `Poky`, plus `meta-ti`. Comme ces deux couches sont des repos Git contenant plusieurs branches, nous allons se baser sur les commits `sumo19.0.0` (de la branche sumo) pour `Poky` et `ti2018.02` pour `meta-ti` (ce choix est basÃ© sur les travaux de [Bootlin](https://bootlin.com/doc/training/yocto/yocto-labs.pdf)).

Sous un nouveau dossier `yocto_workspace`, exÃ©cuter les commandes suivantes dans le terminal pour rÃ©cupÃ©rer le code source des deux repos :

```bash
$ git clone https://git.yoctoproject.org/git/Poky
$ git clone https://git.yoctoproject.org/git/meta-ti
$ cd Poky && git checkout -b BBB sumo-19.0.0
$ cd meta-ti && git checkout -b BBB ti2018.02
```

### Configuration des couches Yocto 

1. Configuration de la couche Poky :

   Nous commenÃ§ons premiÃ¨rement par "sourcer" le fichier `oe-init-build-env` qui permet de crÃ©er lâ€™environnement de build : 

   ```bash
   $ cd Poky && source oe-init-build-env
   ```

   Apres exÃ©cution, nous nous trouvons avec un nouveau dossier `build` sous le rÃ©pertoire `Poky`, contenant deux fichiers de configuration dans un sous-dossier `conf` : `bblayers.conf` et `local.conf`. Ces deux fichiers sont Ã  la base de toute la configuration du systÃ¨me de construction.

   Le premier fichier `bblayers.conf`, comme son nom lâ€™indique, il sert Ã  configurer les couches dans le systÃ¨me de construction. Ce fichier contient, parmi dâ€™autres informations, le chemin vers toutes les couches qui seront utilisÃ©es dans la construction sous la variable `BBLAYERS`. Ci-dessous un aperÃ§u sur le contenu par dÃ©faut de cette variable :

   ![image-20201108170051528](/media/post3/image-20201108170051528.png)

   Notre intÃ©rÃªt est dâ€™utiliser la couche `BSP` `meta-ti`, pour cela nous devons remplacer la derniÃ¨re couche `meta-Poky-bsp` par le chemin vers la couche `meta-ti` que nous avons tÃ©lÃ©chargÃ©e. Les deux premiÃ¨re couches `meta` et `meta-Poky` constituent lâ€™ensemble des mÃ©tadonnÃ©es de base du systÃ¨me de construction et nous devons les garder.

   Pour le deuxiÃ¨me fichier `local.conf`, il sert Ã  dÃ©finir toutes les configurations `Poky` de lâ€™utilisateur local. Dans ce fichier nous dÃ©finissons des valeurs pour diffÃ©rentes variables de configuration. Toute variable dÃ©finie dans ce fichier remplace toute autre dÃ©finition de cette variable dans la repos `Poky` (sauf si celle-ci est codÃ©e en dur : en utilisant `=` Ã  la place de `?=`). Ci-dessous, les modifications que nous devons apporter Ã  ce fichier pour notre cible `BBB` :

   - Configuration de la machine cible : `MACHINE = "beaglebone"`
     *Attention* : Ã  ne pas confondre avec `beaglbone-yocto`, ce sont deux machines diffÃ©rentes. Nâ€™oubliez pas de commenter toute autre dÃ©finition de cette variable.

   - Ajouter les packages essentiels de dÃ©veloppement ( `gcc`, `make`, `pkgconfig` â€¦) plus les outils de profilage (module `lttng`, `valgrind`, â€¦) Ã  lâ€™image gÃ©nÃ©rÃ©e : 
     `EXTRA_IMAGE_FEATURES ?= "debug-tweaks tools-sdk tools-profile"`

2. Configuration de la couche `meta-ti` :

   Ce dossier reprÃ©sente notre couche `BSP`. Il contient des fichiers de configuration pour plusieurs machines sous le rÃ©pertoire `conf/machine`. Parmi ces fichiers, on trouve `beaglbone.conf` qui correspond au fichier de configuration pour notre carte `BBB` (câ€™est le nom de ce fichier que nous avons donnÃ© Ã  la variable `MACHINE` dans le fichier `local.conf` de la couche `Poky`). En plus du dossier `conf`, nous trouvons des dossiers de recettes pour diffÃ©rents packages : `kernel`, `connectivity`, `graphics`, `multimedia`... 

   Sous le dossier `recipes-kernel/linux` nous trouvons la recette du `noyau-rt` `linux-ti-staging-rt_4.14.bb` que nous allons utiliser pour construire notre image temps rÃ©el.

   Lâ€™unique modification de cette couche, concerne le fichier de configuration `conf/machine/beaglbone.conf`. Dans ce fichier nous devons indiquer au systÃ¨me de construction que nous voudrons utiliser le `noyau-rt` dans le `build` de lâ€™image pour cette machine, et ce, en se basant sur la recette `linux-ti-staging-rt_4.14.bb`. Cette modification consiste dâ€™ajouter les deux lignes suivantes dans le fichier de configuration :

   ```
   PREFERRED_PROVIDER_virtual/kernel = "linux-ti-staging-rt"
   COMPATIBLE_MACHINE_beaglebone = "beaglebone"
   ```

   Il est nÃ©cessaire aussi dâ€™intÃ©grer les modules noyau dans lâ€™image finale en ajoutant la ligne ci-dessous :

   `MACHINE_EXTRA_RRECOMMENDS += "kernel-modules"`

### CrÃ©ation dâ€™une image RT 

AprÃ¨s configuration des deux couches, notre systÃ¨me de build est prÃªt pour gÃ©nÃ©rer une image Linux. Par dÃ©faut, la couche `Poky` fournit un ensemble de type dâ€™image prÃªte Ã  Ãªtre construite avec `Bitbake` : `core-image-minimal`, `core-image-sato`, `core-image-base`... 

Pour construire une image minimale, il suffit dâ€™exÃ©cuter la commande : 

```bash
 $ Bitbake core-image-minimal 
```

A la fin dâ€™exÃ©cution de `Bitbake`, les artÃ©facts de construction sont gÃ©nÃ©rÃ©s dans le dossier `build/tmp/deploy/image/beaglbone/` :

- `am335x-boneblack.dtb` : ce fichier correspond au Device Tree Blob, qui dÃ©crit les pÃ©riphÃ©riques de la carte `BBB` au noyau Linux.

- `MLO` : Memory Loader, qui sert Ã  initialiser le systÃ¨me et charger `u-boot`.

- `u-boot.img` : lâ€™image du bootloader `u-boot`. Le rÃ´le final de u-boot est de charger le noyau Linux dans la DDR et de lui passer le contrÃ´le.

- `zImage` : câ€™est lâ€™image binaire du noyau Linux ! 

- `core-image-minimal.rootfs.tar.xz` : fichier compressÃ© du systÃ¨me de fichier Linux. 
  *Note* : Le dossier `boot` du rootfs contient par dÃ©faut la `zImage` et le fichier `dtb`.

- `modules-4.14.93-r0.tgz` : compressÃ© des modules que nous avons construits.

- `core-image-minimal.rootfs.wic.xz` : ce fichier compressÃ© contient tous les Ã©lÃ©ments prÃ©cÃ©dents dans une seule image de type `.wic`. Cette image inclut des commandes de partitionnement permettant dâ€™automatiser le portage de tous les Ã©lÃ©ments de lâ€™image dans le support de la plateforme cible (ex : carte microSD).
  *Note* : le nom `WIC` est dÃ©rivÃ© de `OpenEmbedded` Image Creator : `OEIC->WIC`

Tous les artÃ©facts gÃ©nÃ©rÃ©s sont spÃ©cifiÃ©s par les recettes `Bitbake` liÃ©es Ã  lâ€™image construite : `image-core-minimal.bb`, et Ã  la machine `beaglbone.conf`.

Pour le temps de construction Ã©coulÃ© de cette image minimale, il dÃ©pend essentiellement de deux paramÃ¨tres : le dÃ©bit internet et la puissance de calcul de la machine hÃ´te. Sur ma machine locale (4 coeurs et un dÃ©bit moyen de 200Ko/s), le build de lâ€™image minimal a pris environ 6 heures. AprÃ¨s le premier build, Le projet Yocto garde le code source de tous les packages qui a construit sous le dossier `build/downloads` pour ne pas les retÃ©lÃ©charger dans les prochains build.

Comme cette image nâ€™est quâ€™une image minimale, elle ne contient que le nÃ©cessaire des outils et librairie pour faire marcher une version Linux minimaliste. Donc, on y trouve ni outil de communication : `telnet`, `ssh`.., ni package manager et surtout aucun outil de tests temps rÃ©el comme le package `rt-tests` ou `hwlatdetect`.

Pour rÃ©soudre cela, lâ€™une des solutions est dâ€™essayer dâ€™installer tous les packages manquants de faÃ§on manuelle. Or, Ã  cause des diffÃ©rentes dÃ©pendances entre les packages et les librairiesâ€¦ cette solution risque dâ€™Ãªtre trÃ¨s fastidieuse. La deuxiÃ¨me solution, qui est plutÃ´t Ã  portÃ©e de main, est de demander Ã  `Bitbake` de les installer pour nous, comme les recettes de tous les packages dont nous avons besoin existent dÃ©jÃ  dans la couche `Poky`. 

Nous avons dÃ©cidÃ© donc, de crÃ©er une nouvelle image (recette) appelÃ©e `beaglbone-ti-image-rt.bb`, dans laquelle nous spÃ©cifions toutes les caractÃ©ristiques et packages supplÃ©mentaires dont nous avons besoin. Pour ne pas recrÃ©er toute la base de lâ€™image Linux, cette nouvelle image sera basÃ©e sur lâ€™image existante `core-image-base.bb` qui inclut le support complet de la cible.

Le contenu de cette nouvelle image est prÃ©sentÃ© dans la figure ci-dessous :

![image-20201108170118287](/media/post3/image-20201108170118287.png)

PremiÃ¨rement, nous avons commencÃ© par importer lâ€™image `core-image-base.bb`. Puis, nous avons crÃ©Ã© un script python (optionnel), pour stopper `Bitbake` si lâ€™utilisateur nâ€™a pas spÃ©cifiÃ© son noyau prÃ©fÃ©rÃ© au `noyau-rt` de TI : `linux-ti-staging-rt`. En addition, nous ajoutons les packages et fonctionnalitÃ©s supplÃ©mentaires ci-dessous Ã  lâ€™image finale via les variables `IMAGE_INSTALL` et `IMAGE_FEATURES` :

- `rt-tests` et `hwlatdetect` : ces deux packages contiennent les outils de test temps rÃ©el, comme `cyclictest`, `hackbench` â€¦

- `dropbear` : ce package contient le client `ssh` `dropbear`.

- `package-managment` : ce package permet dâ€™installer les outils de gestion des packages apt.

- `ssh-server-dropbear` : Installer le serveur `ssh` minimal `dropbear`.

IMPORTANT : Pour respecter la structure des couches Yocto, cette nouvelle recette est placÃ©e sous un nouveau dossier images/ dans le dossier `recipes-core/` de la couche `meta-ti`.

Comme prÃ©cÃ©demment, nous gÃ©nÃ©rons cette nouvelle image en lanÃ§ant la commande :

```bash
$ Bitbake beaglbone-ti-image-rt
```

A la fin de lâ€™exÃ©cution, qui prend bien beaucoup plus de temps que lâ€™image minimale, nous obtenons la sortie suivante :

<img src="/media/post3/image-20201109003537657.png" style="zoom: 90%;" />

Dans le dossier `build/tmp/deploy/image/beaglbone/`, nous trouvons les artÃ©facts citÃ©s prÃ©cÃ©demment. 

#### Portage de lâ€™image

Le fichier qui nous intÃ©resse pour le portage de lâ€™image sur une carte microSD correspond au fichier `WIC`. Ce fichier contient toutes les commandes nÃ©cessaires pour partitionner automatiquement la carte microSD et copier dans chaque partition les fichiers correspondants. (Il est possible aussi de porter manuellement tous les Ã©lÃ©ments de build sur la carte SD, Ã  la place dâ€™utiliser le fichier `WIC`)

PremiÃ¨rement, nous commenÃ§ons par dÃ©compresser le fichier `beaglebone-ti-image-rt.rootfs.wic.xz` avec la commande unxz. Pour voir le contenu du fichier `.wic`, il existe lâ€™outil `wic` fourni avec `OpenEmbedded`. Il suffit de sourcer le script `oe-init-build-env` pour lâ€™utiliser :

![image-20201108170811599](/media/post3/image-20201108170811599.png)

La commande `$ wic ls file.wic` permet dâ€™afficher les deux partitions contenues dans le fichier. Pour afficher le contenu de chaque partition, nous ajoutons le numÃ©ro de la partition devant le nom du fichier `$ wic ls file.wic:2`. Dâ€™aprÃ¨s la figure, nous remarquons que notre fichier `wic` contient deux partitions : une de type `Fat16` qui contient les fichiers du bootloader, et lâ€™autre de type `ext4` qui contient le system de fichier root.

Avant de commencer le portage, nous insÃ©rons la carte microSD dans la machine hÃ´te et nous exÃ©cutons la commande `lsblk` pour savoir le nom du volume donnÃ© Ã  la carte microSD :

![image-20201108170859776](/media/post3/image-20201108170859776.png)

Dans ce cas il sâ€™agit du pÃ©riphÃ©rique `sdc`, avec une partition montÃ©e `sdc1`. Nous dÃ©montons, premiÃ¨rement, cette partition pour la dÃ©tachÃ©e du systÃ¨me de fichiers avec la commande :

```bash
$ sudo umount /dev/sdc?
```

Une fois la partition dÃ©montÃ©e, nous Ã©crivons le fichier dâ€™extension .wic directement sur lâ€™ensemble du pÃ©riphÃ©rique reprÃ©sentant la carte microSD :

```bash
$ sudo cp beaglbone-ti-image-rt.wic /dev/sdc
```

A la fin de cette opÃ©ration, la carte microSD est prÃªte et nous pouvons lâ€™Ã©jecter de la machine hÃ´te et lâ€™insÃ©rer dans la `BBB`. Avant de dÃ©marrer la carte, il faut bien savoir les configurations de dÃ©marrage â€“ lâ€™ordre de boot - par dÃ©faut. Pour la `BBB` il y en existe deux : 

- Bouton S2 non appuyÃ© lors de la mise sous tension de la carte :
  1. MMC1 (eMMC)
  2. MMC0 (SD card)
  3. UART0
  4. USB0

- Bouton S2 appuyÃ© lors de la mise sous tension de la carte : 
  1. SPI0
  2. MMC0 (SD card)
  3. USB0
  4. UART0

Donc pour empÃªcher la carte de dÃ©marrer Ã  partir de lâ€™`eMMC` en premier, il faut rester appuyer sur le bouton `S2` de la carte avant alimentation. 

![image-20201108170916357](/media/post3/image-20201108170916357.png)

En branchant un adaptateur usb/FTDI au port `UART` de la `BBB`, et Ã  travers `minicom`, nous obtenons la sortie suivante :

![image-20201108170927324](/media/post3/image-20201108170927324.png)

Donc, nous remarquons bien le bon dÃ©marrage du noyau Linux Ã  partir de la carte microSD.

Pour savoir sâ€™il sâ€™agit dâ€™une image temps rÃ©el (patchÃ©e avec `PREEMPT_RT`), il suffit de voir la sortie de la commande `$ uname -a` si elle affiche le string `PREEMPT RT`, ou, de voir dans le fichier de configuration du noyau, si lâ€™option `CONFIG_PREEMPT_RT_FULL` existe et activÃ©e. La figure ci-dessous montre que notre image est bel et bien patchÃ©e avec `PREEMPT_RT` :

![image-20201108170935854](/media/post3/image-20201108170935854.png)

A noter aussi, que cette image contient tous les outils que nous avons installÃ©s : `ssh`, `apt`, `cyclictest`â€¦

**Comparaison de performance** 

Pour rÃ©aliser le test de performance, nous avons construit une deuxiÃ¨me image pour la BBB , mais cette fois-ci lâ€™image nâ€™est pas RT c.Ã .d elle nâ€™est pas patchÃ©e par `PREEMPT_RT`. Pour cela deux modifications ont Ã©tÃ© apportÃ©es Ã  la configuration prÃ©cÃ©dente :

- Remplacer le contenu de la variable `PREFERRED_PROVIDER_virtual/kernel` par `linux-ti-staging` dans le fichier `beaglebone.conf` de la couche `meta-ti`.

- Dans la recette de lâ€™image crÃ©Ã©e `beaglbone-ti-image-rt.bb`, enlever le script python et renommer cette image Ã  `beaglebone-ti-image.bb`. Il suffira aprÃ¨s dâ€™appeler cette image dans `Bitbake`.

Maintenant que nous avons les deux images : `RT` et `non-RT` avec les packages de test temps rÃ©el installÃ©s, nous pouvons comparer les deux systÃ¨mes. Nous allons baser notre test sur deux outils de benchmarking qui sont souvent utilisÃ©s dans ce contexte : 

- `Cyclictest` : Ce programme permet de qualifier la latence du systÃ¨me en mesurant le temps Ã©coulÃ© entre lâ€™expiration dâ€™un timer et le moment de lâ€™exÃ©cution de la tÃ¢che qui lâ€™a activÃ© :

![image-20201108170943874](/media/post3/image-20201108170943874.png)

- `Hackbench` : Ce programme effectue des mesures de commutation entre threads et processus qui communiquent par des pipes ou des sockets. Ce programme Ã©tant trÃ¨s intensif, nous allons lâ€™utiliser comme Ã©lÃ©ment perturbateur pour les mesures effectuÃ©es avec `cyclictest`.

Les paramÃ¨tres utilisÃ©s pour chaque outil sont dÃ©crits ci-dessous :

```bash
$ cyclictest -a 0 -p 99 -m -n -D 5m -q 
    -a 0 : exÃ©cuter une seule tache sur le CPU0
    -p 99 : utiliser la prioritÃ© temps rÃ©el FIFO 99
    -m : Invoquer mlockall() pour verrouiller la mÃ©moire virtuelle du processus en mÃ©moire physique (pour Ã©viter les problÃ¨mes de page fault).
    -n : utiliser la fonction clock_nanosleep() Ã  la place de nanosleep().
    -D 5m : exÃ©cuter le test pendant 5 minutes. Ce qui correspond Ã  300000 dÃ©clenchement pour la valeur de sleep() par dÃ©faut qui est de 1 ms.
    -q : --quiet : afficher le rÃ©sultat jusquâ€™Ã  la fin de test.
```

```bash
$ hackbench -s 1024 -l 100 --threads -f 40 -g 10
    -s 1024 : configurer la taille des messages Ã©changÃ©s Ã  1024 octet.
    -l 100 : configurer le nombre de messages Ã©changÃ© Ã  100.
    --threads : utiliser des threads Ã  la place des process.
    -f 40 : chaque Ã©metteur/rÃ©cepteur peut ouvrir 40 â€˜file descriptorâ€™.
    -g 10 : dÃ©marrer 10 groupes dâ€™Ã©metteur/rÃ©cepteur.
```

Les tests sont effectuÃ©s sur les deux images `Linux-RT` et `non-RT`. Nous allons rÃ©aliser deux scÃ©narios de tests diffÃ©rents pour chaque image :

1. Un premier test sans charge : nous lanÃ§ons lâ€™outil `cyclictest` tout seul.

2. Un deuxiÃ¨me test avec charge intensive : nous lanÃ§ons `cyclictest` dans un terminal, et en mÃªme temps, nous lanÃ§ons `hackbench`.

Comme nous exÃ©cutons lâ€™outil `cyclictest` pour une durÃ©e de 5 minutes, lors des tests avec charge il faut empÃªcher `hackbench` de terminer avant cette durer. Pour cela, nous avons intÃ©grÃ© la commande `hackbench` dans une boucle `while` Ã  lâ€™aide du script `Bash` ci-dessous : 

```bash
#!/bin/bash
while :
do
     hackbench -s 1024 -l 100 --threads -f 40 -g 10
done
```

AprÃ¨s connexion Ã  la carte, nÃ©cessairement en `ssh` pour Ãªtre capable dâ€™ouvrir deux terminaux, nous exÃ©cutons les scÃ©narios de tests lâ€™un aprÃ¨s lâ€™autre sur les deux images Linux. 

Le tableau ci-dessous, rÃ©sume les rÃ©sultats obtenus de latence (mesurÃ©s par `cyclictest`) pour chaque cas :

![image-20201108171000501](/media/post3/image-20201108171000501.png)

Pour les deux scÃ©narii, nous remarquons une diffÃ©rence sur tout lâ€™intervalle de latence, avec un Ã©cart plutÃ´t important pour la latence maximale entre les deux images : rapport de 10 pour le premier scÃ©nario et de 4.5 pour le deuxiÃ¨me, ce qui est bien attendu, comme les taches temps rÃ©el de `cyclictest` prennent plus du temps `CPU` sur lâ€™image RT (ayant un noyau prÃ©emptif) que sur lâ€™image normale.

 

**RÃ©fÃ©rences** 

https://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html

https://www.yoctoproject.org/docs/2.5/dev-manual/dev-manual.html#understanding-and-creating-layers.

https://bootlin.com/doc/training/yocto/yocto-labs.pdf

https://imxdev.gitlab.io/tutorial/How_to_inspect_OpenEmbedded_kickstart_wic_files/

 

