---
layout: post
title:  "Projet YOCTO : Build d‚Äôune image Linux-RT pour Beaglebone Black"
date:   2020-09-10 15:14:45 +0200
language: FR
categories: linux-driver
excerpt_separator: <!--end_excerpt-->
---

La carte Beaglbone black (`BBB`) est une plateforme embarqu√©e open source utilis√©e dans plusieurs domaines √©ducationnels ainsi qu‚Äôindustriels. Equip√©e d‚Äôun `SOC` am533x de Texas Instrument, cette plateforme est capable de tourner diff√©rents syst√®mes d‚Äôexploitation comme Linux, Android, WinCE‚Ä¶ 
<!--end_excerpt-->

Dans certaines applications, notamment dans le domaine industriel, il est parfois exig√© d‚Äôavoir une performance temps r√©el du system, ce qui n√©cessite l‚Äôutilisation d‚Äôune solution temps r√©el soit software ou hardware. Dans ce manuscrit, nous allons s‚Äôint√©resser √† une solution software open source d√©di√©e au system Linux connue sous le nom : le projet `PREEMPT_RT`.

> "Controlling a laser with Linux is crazy, but everyone in this room is crazy in his own way. So, if you want to use Linux to control an industrial welding laser, I have no problem with your using PREEMPT_RT." -- Linus Torvalds

Le projet `PREEMPT_RT` (fond√© et maintenu par Thomas Gleixner, Ingo Molnar et de nombreux autres collaborateurs) offre une solution temps r√©el ¬´ souple ¬ª qui se pr√©sente sous forme d‚Äôun patch qu‚Äôon peut appliquer sur un noyau Linux standard pour am√©liorer ses performances pour le temps r√©el. L‚Äôapplication du patch `PREEMPT_RT` se fait sur le code source d‚Äôun noyau Linux avant sa compilation. Toutefois, comme le patch n‚Äôest disponible que pour des versions majeures et mineures bien pr√©cises du noyau Linux standard, l‚Äôapplication du patch peut s‚Äôav√©rer d‚Äôune grande complexit√© √† cause des probl√®mes de compatibilit√©.

L‚Äôobjectif de cet article est d‚Äôinvestiguer une technique automatis√©e de construction d‚Äôimage Linux embarqu√© avec le fameux projet Yocto, en construisant une image Linux patch√©e avec `PREEMPT_RT` pour la cible `BBB`. Dans La premi√®re partie, une introduction au syst√®me de construction du projet Yocto et de ses importants outils est pr√©sent√©e. Dans la deuxi√®me partie, nous allons voir la configuration r√©alis√©e pour la construction d‚Äôune image Linux-RT bas√©e sur un noyau fourni par Texas Instrument, puis, nous concluons par faire une comparaison de la performance offerte par cette solution temps r√©el, par rapport √† une impl√©mentation Linux normal. 

 

## Projet Yocto

Le projet Yocto est un projet collaboratif, open source, cr√©√© par la fondation Linux en 2011 avec l‚Äôobjectif de fournir et de cr√©er des outils et processus interop√©rables pour la construction des images Linux personnalis√©es d√©di√©es aux syst√®mes embarqu√©s et IoT, peut-import leurs architectures hardware. Le projet Yocto offre un environnement de d√©veloppement flexible, qui permet aux d√©veloppeurs de syst√®mes embarqu√©s de collaborer √† travers une technologie partag√©e de piles logicielles, de configurations et des meilleures pratiques utilis√©es pour cr√©er des images Linux personnalis√©es.

Ce projet est bas√© sur une plateforme appel√©e `OpenEmbedded` cr√©√©e en 2003, qui est une plateforme de compilation crois√©e automatis√©e, d√©di√©e √† la construction des images Linux embarqu√©e. Le system de construction de cette plateforme utilise un outil qui s‚Äôappelle `Bitbake`, similaire √† l‚Äôoutil `GNU Make`, et qui permet de sp√©cifier les scriptes de construction, appel√©e ¬´ recettes ¬ª dans le langage `Bitbake`, d‚Äôun package donn√©. Les recettes `Bitbake` (extension `.bb`) incluent la liste des d√©pendances de chaque package, la location du source code, et toutes autres informations n√©cessaires qui permettent aux outils `d‚ÄôOpenEmbedded` de cr√©er une image Linux bootable.

Dans la repos officielle ( üïä j'ai l'habitude d'utiliser le mot "la repos" √† la place de " le d√©p√¥t" conform√©ment au mot anglais dominant : Repository ) du projet Yocto : git.yoctoproject.org, nous trouvons une distribution de r√©f√©rence appel√©e `Poky`, qui contient le syst√®me de construction `OpenEmbedded` plus un ensemble de m√©tadonn√©es permettant aux d√©veloppeurs d‚Äôamorcer la construction de leurs distributions personnalis√©es. Cette r√©f√©rence est fournie comme une sp√©cification de base et elle permet - out of the box - de construire une image bootable pour un syst√®me embarqu√© typique.

La figure ci-dessous illustre la relation de `Poky` avec le reste du projet :

![image-20201108170016427](/media/post3/image-20201108170005870.png)

Pour en savoir plus sur `Poky`, voir le lien : [Reference Embedded Distribution (Poky)](https://www.yoctoproject.org/docs/2.5/overview-manual/overview-manual.html#reference-embedded-distribution)

### Mod√®le en couche

L‚Äôun des points forts du projet Yocto et que chaque aspect de construction est contr√¥l√© via les m√©tadonn√©es. En effet, Il est possible d‚Äôajouter/modifier des couches de m√©tadonn√©es permettant l‚Äôajout de nouvelles piles logicielles, du support pour le nouveau hardware (Board Support Packages) ou m√™me cr√©er des nouveaux types d‚Äôimages (image minimale, basique‚Ä¶).

Le mod√®le en couche du projet Yocto sert √† isoler les diff√©rentes personnalisations ajout√©es, dans le but d‚Äôam√©liorer la flexibilit√© et la r√©utilisabilit√© de ses diff√©rents processus de construction : plus la structure est modulaire plus et facile de coop√©rer avec les changements futurs.

Chaque couche Yocto respecte une hi√©rarchie bien pr√©cise, permettant de garder la compatibilit√© et la portabilit√© avec les autres couches du projet. Par commodit√© d‚Äôutilisation, le nom des couches Yocto commence toujours par le pr√©fix `meta-` . Ci-dessous, la composition typique d‚Äôune couche Yocto : 

![image-20201108170028468](/media/post3/image-20201108170028468.png)

Une couche Yocto est compos√©e d‚Äôun dossier obligatoire conf qui contient :

- Le fichier de configuration `layer.conf` indiquant les diff√©rentes recettes offertes par cette couche.

- Le dossier machine qui contient le fichier de configuration `machine.conf` li√©e √† la plateforme cible. 

Plus des dossiers de recettes qui ajoutent le support de nouvelles fonctionnalit√©s, ou √©tendent (fichiers `.bbappend`) celles existantes d√©j√† dans autres couches. Dans la couche de la figure ci-dessus, nous trouvons, en plus du conf, le dossier `recipes-kernel` qui contient une recette `Bitbake` (.bb) pour la construction d‚Äôun noyau Linux.

#### Couche BSP

En effet, les couches Yocto qui ajoutent du support √† des nouvelles machines sont appel√©es des couches `BSP` (Board Support Packages). Il s‚Äôagit d‚Äôune collection d‚Äôinstructions et d‚Äôinformations (des m√©tadonn√©es) qui d√©finit comment prendre en charge un syst√®me ou p√©riph√©rique mat√©riel. Elles incluent des informations sur les fonctionnalit√©s mat√©rielles pr√©sentes sur le p√©riph√©rique, les informations de configuration du noyau ainsi que tout pilote mat√©riel suppl√©mentaire requis. Elles ajoutent √©galement tous les composants logiciels suppl√©mentaires en addition au stack Linux, pour les fonctionnalit√©s du p√©riph√©rique essentielles et facultatives.

### Bitbake

`BitBake` se trouve au c≈ìur du syst√®me de build `OpenEmbedded`. C‚Äôest un syst√®me g√©n√©rique d'ex√©cution de t√¢ches (√©crit en `Python`), qui permet aux t√¢ches `shell` et `Python` d'√™tre ex√©cut√©es efficacement et en parall√®le tout en travaillant dans des contraintes de d√©pendance inter-t√¢ches complexes.

Conceptuellement, `BitBake` est similaire √† `GNU Make` √† certains √©gards :

- `BitBake` ex√©cute les t√¢ches en fonction des m√©tadonn√©es fournies de chaque package. Les m√©tadonn√©es sont stock√©es dans les fichiers recettes (`.bb`), fichiers de configuration (`.conf`) et de classe (`.bbclass`) qui fournissent √† `BitBake` toutes les instructions sur les t√¢ches √† ex√©cuter et leurs interd√©pendances.

- `BitBake` inclut toute une biblioth√®que d√©dier √† la r√©cup√©ration du code source de divers endroits (syst√®mes de contr√¥le de source, serveurs Web,‚Ä¶) et qui supporte plusieurs protocoles : git, https, ftp, file, ssh‚Ä¶

- `Bitbake` utilise un model client/serveur, qui permet de l‚Äôutiliser √† partir de la ligne de commande ou comme un service via XML-RPC.

#### Les recettes Bitbake :

Ce sont des fichiers d√©sign√©s par l'extension `.bb`, et ils repr√©sentent les briques √©l√©mentaires des m√©tadonn√©es. Chaque fichier recette, fournit toutes les informations n√©cessaires √† la construction du package correspondant. Ces informations sont organis√©es dans des variables ou cod√©es dans des fonctions pr√©d√©finies par `Bitbake` :

- Une description du package : Dans la variable `DESCRIPTION`.

- La version de la recette : Dans la variable `PV`.

- Les d√©pendances existantes : Dans la variable `DEPENDS`.

- La location du source code du package : Dans la variable `SRC_URI`.

- La location des diff√©rents patches √† appliquer au code source, s‚Äôil y en existe : Dans la variable `SRC_URI`.

- Comment configurer et compiler le code source : Dans les fonction `do_configure()` et `do_compile()`

- O√π installer le package : Dans la fonction `do_install()`

En addition, les recettes `Bitbake` utilisent une convention de nommage standard qui inclut le nom du package plus sa version dans le nom de la recette. C‚Äôest une r√®gle de nommage √† respecter, comme ces valeurs sont automatiquement prises par `Bitbake` et lui permet de localiser toutes les recettes disponibles et leurs versions correspondantes. Le format attendu du nom d‚Äôune recette est le suivant : `packagename_version-r1.bb` avec `r1` le num√©ro du release (s‚Äôil n‚Äôest pas sp√©cifi√©, sa valeur par d√©faut est `r0`). Par exemple, dans la couche Yocto de la figure pr√©c√©dente, nous avions une recette pour la construction d‚Äôun package `linux-yocto` de version `5.4`. 

> Note : Pour choisir cette recette dans le build d‚Äôune machine, au cas o√π il y‚Äôen a plusieurs pour diff√©rentes versions, il suffit de sp√©cifier dans le fichier `machine.conf` la version pr√©f√©r√©e en utilisant la notation suivante :        `PREFERRED_VERSION_linux-yocto = "5.4"` 



## Construction d‚Äôune image temps r√©el pour la BeagleBone Black

### Pr√©paration du Workspace 

Pour utiliser le projet Yocto, il est n√©cessaire d‚Äôabord d‚Äôavoir une machine de d√©veloppement avec un minimum de 50 Go d'espace disque libre et qui ex√©cute une distribution Linux prise en charge (voir le [lien](http://www.yoctoproject.org/docs/2.4.2/ref-manual/ref-manual.html#detailed-supported-distros)).

- Installation des packages essentiels :

Ce sont les principaux outils et packages n√©cessaires √† la construction avec le projet Yocto. Ceux-ci incluent le compilateur `GNU GCC`, un syst√®me de contr√¥le de versions, plus d'autres packages selon ce qu‚Äôon veut faire (ajouter du support graphique, g√©n√©rer la doc ‚Ä¶ etc). Ci-dessous la commande pour obtenir l'essentiel sur Ubuntu :

```bash
$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm
```

- R√©cup√©ration des couches de m√©tadonn√©es n√©cessaires :

Pour notre cible `BBB`, nous allons se baser sur la couche `Poky`, mais en plus, nous avons besoin de la couche `BSP` sp√©cifique au hardware de la carte `BBB`. Pour cela nous allons utiliser la couche `meta-ti` de la part de Texas Instrument (qui est le vendeur du `SOC` amx335 de la carte `BBB`) fournie dans la repos officielle du projet Yocto. Dans cette couche, en plus des recettes `BSP` qui incluent les configurations hardwares, nous trouvons les recettes de construction des noyaux `Linux-rt` et `non-rt` fournies par TI ainsi que des recettes personnalis√©es avec des fonctionnalit√©s suppl√©mentaires compatibles avec la carte `BBB`.

Nous avons besoin donc, de deux couches : `Poky`, plus `meta-ti`. Comme ces deux couches sont des repos Git contenant plusieurs branches, nous allons se baser sur les commits `sumo19.0.0` (de la branche sumo) pour `Poky` et `ti2018.02` pour `meta-ti` (ce choix est bas√© sur les travaux de [Bootlin](https://bootlin.com/doc/training/yocto/yocto-labs.pdf)).

Sous un nouveau dossier `yocto_workspace`, ex√©cuter les commandes suivantes dans le terminal pour r√©cup√©rer le code source des deux repos :

```bash
$ git clone https://git.yoctoproject.org/git/Poky
$ git clone https://git.yoctoproject.org/git/meta-ti
$ cd Poky && git checkout -b BBB sumo-19.0.0
$ cd meta-ti && git checkout -b BBB ti2018.02
```

### Configuration des couches Yocto 

1. Configuration de la couche Poky :

   Nous commen√ßons premi√®rement par "sourcer" le fichier `oe-init-build-env` qui permet de cr√©er l‚Äôenvironnement de build : 

   ```bash
   $ cd Poky && source oe-init-build-env
   ```

   Apres ex√©cution, nous nous trouvons avec un nouveau dossier `build` sous le r√©pertoire `Poky`, contenant deux fichiers de configuration dans un sous-dossier `conf` : `bblayers.conf` et `local.conf`. Ces deux fichiers sont √† la base de toute la configuration du syst√®me de construction.

   Le premier fichier `bblayers.conf`, comme son nom l‚Äôindique, il sert √† configurer les couches dans le syst√®me de construction. Ce fichier contient, parmi d‚Äôautres informations, le chemin vers toutes les couches qui seront utilis√©es dans la construction sous la variable `BBLAYERS`. Ci-dessous un aper√ßu sur le contenu par d√©faut de cette variable :

   ![image-20201108170051528](/media/post3/image-20201108170051528.png)

   Notre int√©r√™t est d‚Äôutiliser la couche `BSP` `meta-ti`, pour cela nous devons remplacer la derni√®re couche `meta-Poky-bsp` par le chemin vers la couche `meta-ti` que nous avons t√©l√©charg√©e. Les deux premi√®re couches `meta` et `meta-Poky` constituent l‚Äôensemble des m√©tadonn√©es de base du syst√®me de construction et nous devons les garder.

   Pour le deuxi√®me fichier `local.conf`, il sert √† d√©finir toutes les configurations `Poky` de l‚Äôutilisateur local. Dans ce fichier nous d√©finissons des valeurs pour diff√©rentes variables de configuration. Toute variable d√©finie dans ce fichier remplace toute autre d√©finition de cette variable dans la repos `Poky` (sauf si celle-ci est cod√©e en dur : en utilisant `=` √† la place de `?=`). Ci-dessous, les modifications que nous devons apporter √† ce fichier pour notre cible `BBB` :

   - Configuration de la machine cible : `MACHINE = "beaglebone"`
     *Attention* : √† ne pas confondre avec `beaglbone-yocto`, ce sont deux machines diff√©rentes. N‚Äôoubliez pas de commenter toute autre d√©finition de cette variable.

   - Ajouter les packages essentiels de d√©veloppement ( `gcc`, `make`, `pkgconfig` ‚Ä¶) plus les outils de profilage (module `lttng`, `valgrind`, ‚Ä¶) √† l‚Äôimage g√©n√©r√©e : 
     `EXTRA_IMAGE_FEATURES ?= "debug-tweaks tools-sdk tools-profile"`

2. Configuration de la couche `meta-ti` :

   Ce dossier repr√©sente notre couche `BSP`. Il contient des fichiers de configuration pour plusieurs machines sous le r√©pertoire `conf/machine`. Parmi ces fichiers, on trouve `beaglbone.conf` qui correspond au fichier de configuration pour notre carte `BBB` (c‚Äôest le nom de ce fichier que nous avons donn√© √† la variable `MACHINE` dans le fichier `local.conf` de la couche `Poky`). En plus du dossier `conf`, nous trouvons des dossiers de recettes pour diff√©rents packages : `kernel`, `connectivity`, `graphics`, `multimedia`... 

   Sous le dossier `recipes-kernel/linux` nous trouvons la recette du `noyau-rt` `linux-ti-staging-rt_4.14.bb` que nous allons utiliser pour construire notre image temps r√©el.

   L‚Äôunique modification de cette couche, concerne le fichier de configuration `conf/machine/beaglbone.conf`. Dans ce fichier nous devons indiquer au syst√®me de construction que nous voudrons utiliser le `noyau-rt` dans le `build` de l‚Äôimage pour cette machine, et ce, en se basant sur la recette `linux-ti-staging-rt_4.14.bb`. Cette modification consiste d‚Äôajouter les deux lignes suivantes dans le fichier de configuration :

   ```
   PREFERRED_PROVIDER_virtual/kernel = "linux-ti-staging-rt"
   COMPATIBLE_MACHINE_beaglebone = "beaglebone"
   ```

   Il est n√©cessaire aussi d‚Äôint√©grer les modules noyau dans l‚Äôimage finale en ajoutant la ligne ci-dessous :

   `MACHINE_EXTRA_RRECOMMENDS += "kernel-modules"`

### Cr√©ation d‚Äôune image RT 

Apr√®s configuration des deux couches, notre syst√®me de build est pr√™t pour g√©n√©rer une image Linux. Par d√©faut, la couche `Poky` fournit un ensemble de type d‚Äôimage pr√™te √† √™tre construite avec `Bitbake` : `core-image-minimal`, `core-image-sato`, `core-image-base`... 

Pour construire une image minimale, il suffit d‚Äôex√©cuter la commande : 

```bash
 $ Bitbake core-image-minimal 
```

A la fin d‚Äôex√©cution de `Bitbake`, les art√©facts de construction sont g√©n√©r√©s dans le dossier `build/tmp/deploy/image/beaglbone/` :

- `am335x-boneblack.dtb` : ce fichier correspond au Device Tree Blob, qui d√©crit les p√©riph√©riques de la carte `BBB` au noyau Linux.

- `MLO` : Memory Loader, qui sert √† initialiser le syst√®me et charger `u-boot`.

- `u-boot.img` : l‚Äôimage du bootloader `u-boot`. Le r√¥le final de u-boot est de charger le noyau Linux dans la DDR et de lui passer le contr√¥le.

- `zImage` : c‚Äôest l‚Äôimage binaire du noyau Linux ! 

- `core-image-minimal.rootfs.tar.xz` : fichier compress√© du syst√®me de fichier Linux. 
  *Note* : Le dossier `boot` du rootfs contient par d√©faut la `zImage` et le fichier `dtb`.

- `modules-4.14.93-r0.tgz` : compress√© des modules que nous avons construits.

- `core-image-minimal.rootfs.wic.xz` : ce fichier compress√© contient tous les √©l√©ments pr√©c√©dents dans une seule image de type `.wic`. Cette image inclut des commandes de partitionnement permettant d‚Äôautomatiser le portage de tous les √©l√©ments de l‚Äôimage dans le support de la plateforme cible (ex : carte microSD).
  *Note* : le nom `WIC` est d√©riv√© de `OpenEmbedded` Image Creator : `OEIC->WIC`

Tous les art√©facts g√©n√©r√©s sont sp√©cifi√©s par les recettes `Bitbake` li√©es √† l‚Äôimage construite : `image-core-minimal.bb`, et √† la machine `beaglbone.conf`.

Pour le temps de construction √©coul√© de cette image minimale, il d√©pend essentiellement de deux param√®tres : le d√©bit internet et la puissance de calcul de la machine h√¥te. Sur ma machine locale (4 coeurs et un d√©bit moyen de 200Ko/s), le build de l‚Äôimage minimal a pris environ 6 heures. Apr√®s le premier build, Le projet Yocto garde le code source de tous les packages qui a construit sous le dossier `build/downloads` pour ne pas les ret√©l√©charger dans les prochains build.

Comme cette image n‚Äôest qu‚Äôune image minimale, elle ne contient que le n√©cessaire des outils et librairie pour faire marcher une version Linux minimaliste. Donc, on y trouve ni outil de communication : `telnet`, `ssh`.., ni package manager et surtout aucun outil de tests temps r√©el comme le package `rt-tests` ou `hwlatdetect`.

Pour r√©soudre cela, l‚Äôune des solutions est d‚Äôessayer d‚Äôinstaller tous les packages manquants de fa√ßon manuelle. Or, √† cause des diff√©rentes d√©pendances entre les packages et les librairies‚Ä¶ cette solution risque d‚Äô√™tre tr√®s fastidieuse. La deuxi√®me solution, qui est plut√¥t √† port√©e de main, est de demander √† `Bitbake` de les installer pour nous, comme les recettes de tous les packages dont nous avons besoin existent d√©j√† dans la couche `Poky`. 

Nous avons d√©cid√© donc, de cr√©er une nouvelle image (recette) appel√©e `beaglbone-ti-image-rt.bb`, dans laquelle nous sp√©cifions toutes les caract√©ristiques et packages suppl√©mentaires dont nous avons besoin. Pour ne pas recr√©er toute la base de l‚Äôimage Linux, cette nouvelle image sera bas√©e sur l‚Äôimage existante `core-image-base.bb` qui inclut le support complet de la cible.

Le contenu de cette nouvelle image est pr√©sent√© dans la figure ci-dessous :

![image-20201108170118287](/media/post3/image-20201108170118287.png)

Premi√®rement, nous avons commenc√© par importer l‚Äôimage `core-image-base.bb`. Puis, nous avons cr√©√© un script python (optionnel), pour stopper `Bitbake` si l‚Äôutilisateur n‚Äôa pas sp√©cifi√© son noyau pr√©f√©r√© au `noyau-rt` de TI : `linux-ti-staging-rt`. En addition, nous ajoutons les packages et fonctionnalit√©s suppl√©mentaires ci-dessous √† l‚Äôimage finale via les variables `IMAGE_INSTALL` et `IMAGE_FEATURES` :

- `rt-tests` et `hwlatdetect` : ces deux packages contiennent les outils de test temps r√©el, comme `cyclictest`, `hackbench` ‚Ä¶

- `dropbear` : ce package contient le client `ssh` `dropbear`.

- `package-managment` : ce package permet d‚Äôinstaller les outils de gestion des packages apt.

- `ssh-server-dropbear` : Installer le serveur `ssh` minimal `dropbear`.

IMPORTANT : Pour respecter la structure des couches Yocto, cette nouvelle recette est plac√©e sous un nouveau dossier images/ dans le dossier `recipes-core/` de la couche `meta-ti`.

Comme pr√©c√©demment, nous g√©n√©rons cette nouvelle image en lan√ßant la commande :

```bash
$ Bitbake beaglbone-ti-image-rt
```

A la fin de l‚Äôex√©cution, qui prend bien beaucoup plus de temps que l‚Äôimage minimale, nous obtenons la sortie suivante :

<img src="/media/post3/image-20201109003537657.png" style="zoom: 90%;" />

Dans le dossier `build/tmp/deploy/image/beaglbone/`, nous trouvons les art√©facts cit√©s pr√©c√©demment. 

#### Portage de l‚Äôimage

Le fichier qui nous int√©resse pour le portage de l‚Äôimage sur une carte microSD correspond au fichier `WIC`. Ce fichier contient toutes les commandes n√©cessaires pour partitionner automatiquement la carte microSD et copier dans chaque partition les fichiers correspondants. (Il est possible aussi de porter manuellement tous les √©l√©ments de build sur la carte SD, √† la place d‚Äôutiliser le fichier `WIC`)

Premi√®rement, nous commen√ßons par d√©compresser le fichier `beaglebone-ti-image-rt.rootfs.wic.xz` avec la commande unxz. Pour voir le contenu du fichier `.wic`, il existe l‚Äôoutil `wic` fourni avec `OpenEmbedded`. Il suffit de sourcer le script `oe-init-build-env` pour l‚Äôutiliser :

![image-20201108170811599](/media/post3/image-20201108170811599.png)

La commande `$ wic ls file.wic` permet d‚Äôafficher les deux partitions contenues dans le fichier. Pour afficher le contenu de chaque partition, nous ajoutons le num√©ro de la partition devant le nom du fichier `$ wic ls file.wic:2`. D‚Äôapr√®s la figure, nous remarquons que notre fichier `wic` contient deux partitions : une de type `Fat16` qui contient les fichiers du bootloader, et l‚Äôautre de type `ext4` qui contient le system de fichier root.

Avant de commencer le portage, nous ins√©rons la carte microSD dans la machine h√¥te et nous ex√©cutons la commande `lsblk` pour savoir le nom du volume donn√© √† la carte microSD :

![image-20201108170859776](/media/post3/image-20201108170859776.png)

Dans ce cas il s‚Äôagit du p√©riph√©rique `sdc`, avec une partition mont√©e `sdc1`. Nous d√©montons, premi√®rement, cette partition pour la d√©tach√©e du syst√®me de fichiers avec la commande :

```bash
$ sudo umount /dev/sdc?
```

Une fois la partition d√©mont√©e, nous √©crivons le fichier d‚Äôextension .wic directement sur l‚Äôensemble du p√©riph√©rique repr√©sentant la carte microSD :

```bash
$ sudo cp beaglbone-ti-image-rt.wic /dev/sdc
```

A la fin de cette op√©ration, la carte microSD est pr√™te et nous pouvons l‚Äô√©jecter de la machine h√¥te et l‚Äôins√©rer dans la `BBB`. Avant de d√©marrer la carte, il faut bien savoir les configurations de d√©marrage ‚Äì l‚Äôordre de boot - par d√©faut. Pour la `BBB` il y en existe deux : 

- Bouton S2 non appuy√© lors de la mise sous tension de la carte :
  1. MMC1 (eMMC)
  2. MMC0 (SD card)
  3. UART0
  4. USB0

- Bouton S2 appuy√© lors de la mise sous tension de la carte : 
  1. SPI0
  2. MMC0 (SD card)
  3. USB0
  4. UART0

Donc pour emp√™cher la carte de d√©marrer √† partir de l‚Äô`eMMC` en premier, il faut rester appuyer sur le bouton `S2` de la carte avant alimentation. 

![image-20201108170916357](/media/post3/image-20201108170916357.png)

En branchant un adaptateur usb/FTDI au port `UART` de la `BBB`, et √† travers `minicom`, nous obtenons la sortie suivante :

![image-20201108170927324](/media/post3/image-20201108170927324.png)

Donc, nous remarquons bien le bon d√©marrage du noyau Linux √† partir de la carte microSD.

Pour savoir s‚Äôil s‚Äôagit d‚Äôune image temps r√©el (patch√©e avec `PREEMPT_RT`), il suffit de voir la sortie de la commande `$ uname -a` si elle affiche le string `PREEMPT RT`, ou, de voir dans le fichier de configuration du noyau, si l‚Äôoption `CONFIG_PREEMPT_RT_FULL` existe et activ√©e. La figure ci-dessous montre que notre image est bel et bien patch√©e avec `PREEMPT_RT` :

![image-20201108170935854](/media/post3/image-20201108170935854.png)

A noter aussi, que cette image contient tous les outils que nous avons install√©s : `ssh`, `apt`, `cyclictest`‚Ä¶

**Comparaison de performance** 

Pour r√©aliser le test de performance, nous avons construit une deuxi√®me image pour la BBB , mais cette fois-ci l‚Äôimage n‚Äôest pas RT c.√†.d elle n‚Äôest pas patch√©e par `PREEMPT_RT`. Pour cela deux modifications ont √©t√© apport√©es √† la configuration pr√©c√©dente :

- Remplacer le contenu de la variable `PREFERRED_PROVIDER_virtual/kernel` par `linux-ti-staging` dans le fichier `beaglebone.conf` de la couche `meta-ti`.

- Dans la recette de l‚Äôimage cr√©√©e `beaglbone-ti-image-rt.bb`, enlever le script python et renommer cette image √† `beaglebone-ti-image.bb`. Il suffira apr√®s d‚Äôappeler cette image dans `Bitbake`.

Maintenant que nous avons les deux images : `RT` et `non-RT` avec les packages de test temps r√©el install√©s, nous pouvons comparer les deux syst√®mes. Nous allons baser notre test sur deux outils de benchmarking qui sont souvent utilis√©s dans ce contexte : 

- `Cyclictest` : Ce programme permet de qualifier la latence du syst√®me en mesurant le temps √©coul√© entre l‚Äôexpiration d‚Äôun timer et le moment de l‚Äôex√©cution de la t√¢che qui l‚Äôa activ√© :

![image-20201108170943874](/media/post3/image-20201108170943874.png)

- `Hackbench` : Ce programme effectue des mesures de commutation entre threads et processus qui communiquent par des pipes ou des sockets. Ce programme √©tant tr√®s intensif, nous allons l‚Äôutiliser comme √©l√©ment perturbateur pour les mesures effectu√©es avec `cyclictest`.

Les param√®tres utilis√©s pour chaque outil sont d√©crits ci-dessous :

```bash
$ cyclictest -a 0 -p 99 -m -n -D 5m -q 
    -a 0 : ex√©cuter une seule tache sur le CPU0
    -p 99 : utiliser la priorit√© temps r√©el FIFO 99
    -m : Invoquer mlockall() pour verrouiller la m√©moire virtuelle du processus en m√©moire physique (pour √©viter les probl√®mes de page fault).
    -n : utiliser la fonction clock_nanosleep() √† la place de nanosleep().
    -D 5m : ex√©cuter le test pendant 5 minutes. Ce qui correspond √† 300000 d√©clenchement pour la valeur de sleep() par d√©faut qui est de 1 ms.
    -q : --quiet : afficher le r√©sultat jusqu‚Äô√† la fin de test.
```

```bash
$ hackbench -s 1024 -l 100 --threads -f 40 -g 10
    -s 1024 : configurer la taille des messages √©chang√©s √† 1024 octet.
    -l 100 : configurer le nombre de messages √©chang√© √† 100.
    --threads : utiliser des threads √† la place des process.
    -f 40 : chaque √©metteur/r√©cepteur peut ouvrir 40 ‚Äòfile descriptor‚Äô.
    -g 10 : d√©marrer 10 groupes d‚Äô√©metteur/r√©cepteur.
```

Les tests sont effectu√©s sur les deux images `Linux-RT` et `non-RT`. Nous allons r√©aliser deux sc√©narios de tests diff√©rents pour chaque image :

1. Un premier test sans charge : nous lan√ßons l‚Äôoutil `cyclictest` tout seul.

2. Un deuxi√®me test avec charge intensive : nous lan√ßons `cyclictest` dans un terminal, et en m√™me temps, nous lan√ßons `hackbench`.

Comme nous ex√©cutons l‚Äôoutil `cyclictest` pour une dur√©e de 5 minutes, lors des tests avec charge il faut emp√™cher `hackbench` de terminer avant cette durer. Pour cela, nous avons int√©gr√© la commande `hackbench` dans une boucle `while` √† l‚Äôaide du script `Bash` ci-dessous : 

```bash
#!/bin/bash
while :
do
     hackbench -s 1024 -l 100 --threads -f 40 -g 10
done
```

Apr√®s connexion √† la carte, n√©cessairement en `ssh` pour √™tre capable d‚Äôouvrir deux terminaux, nous ex√©cutons les sc√©narios de tests l‚Äôun apr√®s l‚Äôautre sur les deux images Linux. 

Le tableau ci-dessous, r√©sume les r√©sultats obtenus de latence (mesur√©s par `cyclictest`) pour chaque cas :

![image-20201108171000501](/media/post3/image-20201108171000501.png)

Pour les deux sc√©narii, nous remarquons une diff√©rence sur tout l‚Äôintervalle de latence, avec un √©cart plut√¥t important pour la latence maximale entre les deux images : rapport de 10 pour le premier sc√©nario et de 4.5 pour le deuxi√®me, ce qui est bien attendu, comme les taches temps r√©el de `cyclictest` prennent plus du temps `CPU` sur l‚Äôimage RT (ayant un noyau pr√©emptif) que sur l‚Äôimage normale.

 

**R√©f√©rences** 

https://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html

https://www.yoctoproject.org/docs/2.5/dev-manual/dev-manual.html#understanding-and-creating-layers.

https://bootlin.com/doc/training/yocto/yocto-labs.pdf

https://imxdev.gitlab.io/tutorial/How_to_inspect_OpenEmbedded_kickstart_wic_files/

 

